'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tenonVue = require('@hummer/tenon-vue');

const storeKey = 'store';
function useStore(key) {
    return tenonVue.inject(key || storeKey);
}

function find(list, f) {
    return list.filter(f)[0];
}
function deepCopy(obj, cache = []) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    const hit = find(cache, (c) => c.original === obj);
    if (hit) {
        return hit.copy;
    }
    const copy = Array.isArray(obj) ? [] : {};
    cache.push({
        original: obj,
        copy
    });
    Object.keys(obj).forEach(key => {
        copy[key] = deepCopy(obj[key], cache);
    });
    return copy;
}
function forEachValue(obj, fn) {
    Object.keys(obj).forEach(key => fn(obj[key], key));
}
function isObject$1(obj) {
    return obj !== null && typeof obj === 'object';
}
function isPromise(val) {
    return val && typeof val.then === 'function';
}
function partial(fn, arg) {
    return function () {
        return fn(arg);
    };
}

class Module {
    constructor(rawModule, runtime) {
        this.runtime = runtime;
        this._children = Object.create(null);
        this._rawModule = rawModule;
        const rawState = rawModule.state;
        this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
    }
    get namespaced() {
        return !!this._rawModule.namespaced;
    }
    addChild(key, module) {
        this._children[key] = module;
    }
    removeChild(key) {
        delete this._children[key];
    }
    getChild(key) {
        return this._children[key];
    }
    hasChild(key) {
        return key in this._children;
    }
    update(rawModule) {
        this._rawModule.namespaced = rawModule.namespaced;
        if (rawModule.actions) {
            this._rawModule.actions = rawModule.actions;
        }
        if (rawModule.mutations) {
            this._rawModule.mutations = rawModule.mutations;
        }
        if (rawModule.getters) {
            this._rawModule.getters = rawModule.getters;
        }
    }
    forEachChild(fn) {
        forEachValue(this._children, fn);
    }
    forEachGetter(fn) {
        if (this._rawModule.getters) {
            forEachValue(this._rawModule.getters, fn);
        }
    }
    forEachAction(fn) {
        if (this._rawModule.actions) {
            forEachValue(this._rawModule.actions, fn);
        }
    }
    forEachMutation(fn) {
        if (this._rawModule.mutations) {
            forEachValue(this._rawModule.mutations, fn);
        }
    }
}

class ModuleCollection {
    constructor(rawRootModule) {
        this.register([], rawRootModule, false);
    }
    get(path) {
        return path.reduce((module, key) => {
            return module.getChild(key);
        }, this.root);
    }
    getNamespace(path) {
        let module = this.root;
        return path.reduce((namespace, key) => {
            module = module.getChild(key);
            return namespace + (module.namespaced ? key + '/' : '');
        }, '');
    }
    update(rawRootModule) {
        update([], this.root, rawRootModule);
    }
    register(path, rawModule, runtime = true) {
        const newModule = new Module(rawModule, runtime);
        if (path.length === 0) {
            this.root = newModule;
        }
        else {
            const parent = this.get(path.slice(0, -1));
            parent.addChild(path[path.length - 1], newModule);
        }
        if (rawModule.modules) {
            forEachValue(rawModule.modules, (rawChildModule, key) => {
                this.register(path.concat(key), rawChildModule, runtime);
            });
        }
    }
    unregister(path) {
        const parent = this.get(path.slice(0, -1));
        const key = path[path.length - 1];
        const child = parent.getChild(key);
        if (!child) {
            return;
        }
        if (!child.runtime) {
            return;
        }
        parent.removeChild(key);
    }
    isRegistered(path) {
        const parent = this.get(path.slice(0, -1));
        const key = path[path.length - 1];
        return parent.hasChild(key);
    }
}
function update(path, targetModule, newModule) {
    targetModule.update(newModule);
    if (newModule.modules) {
        for (const key in newModule.modules) {
            if (!targetModule.getChild(key)) {
                return;
            }
            update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
        }
    }
}

function createStore(options) {
    return new Store(options);
}
class Store {
    constructor(options = {}) {
        const { plugins = [], strict = false } = options;
        this._committing = false;
        this._actions = Object.create(null);
        this._actionSubscribers = [];
        this._mutations = Object.create(null);
        this._wrappedGetters = Object.create(null);
        this._modules = new ModuleCollection(options);
        this._modulesNamespaceMap = Object.create(null);
        this._subscribers = [];
        this._makeLocalGettersCache = Object.create(null);
        const store = this;
        const { dispatch, commit } = this;
        this.dispatch = function boundDispatch(type, payload) {
            return dispatch.call(store, type, payload);
        };
        this.commit = function boundCommit(type, payload, options) {
            return commit.call(store, type, payload, options);
        };
        this.strict = strict;
        const state = this._modules.root.state;
        installModule(this, state, [], this._modules.root);
        resetStoreState(this, state);
        plugins.forEach(plugin => plugin(this));
    }
    install(app, injectKey) {
        app.provide(injectKey || storeKey, this);
        app.config.globalProperties.$store = this;
    }
    get state() {
        return this._state.data;
    }
    set state(v) {
    }
    commit(_type, _payload, _options) {
        const { type, payload, options } = unifyObjectStyle(_type, _payload, _options);
        const mutation = { type, payload };
        const entry = this._mutations[type];
        if (!entry) {
            return;
        }
        this._withCommit(() => {
            entry.forEach(function commitIterator(handler) {
                handler(payload);
            });
        });
        this._subscribers
            .slice()
            .forEach((sub) => sub(mutation, this.state));
    }
    dispatch(_type, _payload) {
        const { type, payload } = unifyObjectStyle(_type, _payload);
        const action = { type, payload };
        const entry = this._actions[type];
        if (!entry) {
            return;
        }
        try {
            this._actionSubscribers
                .slice()
                .filter(sub => sub.before)
                .forEach(sub => sub.before(action, this.state));
        }
        catch (e) {
        }
        const result = entry.length > 1
            ? Promise.all(entry.map((handler) => handler(payload)))
            : entry[0](payload);
        return new Promise((resolve, reject) => {
            result.then((res) => {
                try {
                    this._actionSubscribers
                        .filter(sub => sub.after)
                        .forEach(sub => sub.after(action, this.state));
                }
                catch (e) {
                }
                resolve(res);
            }, (error) => {
                try {
                    this._actionSubscribers
                        .filter(sub => sub.error)
                        .forEach(sub => sub.error(action, this.state, error));
                }
                catch (e) {
                }
                reject(error);
            });
        });
    }
    subscribe(fn, options) {
        return genericSubscribe(fn, this._subscribers, options);
    }
    subscribeAction(fn, options) {
        const subs = typeof fn === 'function' ? { before: fn } : fn;
        return genericSubscribe(subs, this._actionSubscribers, options);
    }
    watch(getter, cb, options) {
        return tenonVue.watch(() => getter(this.state, this.getters), cb, Object.assign({}, options));
    }
    replaceState(state) {
        this._withCommit(() => {
            this._state.data = state;
        });
    }
    registerModule(path, rawModule, options = {}) {
        if (typeof path === 'string')
            path = [path];
        this._modules.register(path, rawModule);
        installModule(this, this.state, path, this._modules.get(path), options.preserveState);
        resetStoreState(this, this.state);
    }
    unregisterModule(path) {
        if (typeof path === 'string')
            path = [path];
        this._modules.unregister(path);
        this._withCommit(() => {
            const parentState = getNestedState(this.state, path.slice(0, -1));
            delete parentState[path[path.length - 1]];
        });
        resetStore$1(this);
    }
    hasModule(path) {
        if (typeof path === 'string')
            path = [path];
        return this._modules.isRegistered(path);
    }
    hotUpdate(newOptions) {
        this._modules.update(newOptions);
        resetStore$1(this, true);
    }
    _withCommit(fn) {
        const committing = this._committing;
        this._committing = true;
        fn();
        this._committing = committing;
    }
}
function genericSubscribe(fn, subs, options) {
    if (subs.indexOf(fn) < 0) {
        options && options.prepend
            ? subs.unshift(fn)
            : subs.push(fn);
    }
    return () => {
        const i = subs.indexOf(fn);
        if (i > -1) {
            subs.splice(i, 1);
        }
    };
}
function resetStore$1(store, hot) {
    store._actions = Object.create(null);
    store._mutations = Object.create(null);
    store._wrappedGetters = Object.create(null);
    store._modulesNamespaceMap = Object.create(null);
    const state = store.state;
    installModule(store, state, [], store._modules.root, true);
    resetStoreState(store, state, hot);
}
function resetStoreState(store, state, hot) {
    const oldState = store._state;
    store.getters = {};
    store._makeLocalGettersCache = Object.create(null);
    const wrappedGetters = store._wrappedGetters;
    const computedObj = {};
    forEachValue(wrappedGetters, (fn, key) => {
        computedObj[key] = partial(fn, store);
        Object.defineProperty(store.getters, key, {
            get: () => tenonVue.computed(() => computedObj[key]()).value,
            enumerable: true
        });
    });
    store._state = tenonVue.reactive({
        data: state
    });
    if (store.strict) {
        enableStrictMode(store);
    }
    if (oldState) {
        if (hot) {
            store._withCommit(() => {
                oldState.data = null;
            });
        }
    }
}
function installModule(store, rootState, path, module, hot) {
    const isRoot = !path.length;
    const namespace = store._modules.getNamespace(path);
    if (module.namespaced) {
        if (store._modulesNamespaceMap[namespace] && false) ;
        store._modulesNamespaceMap[namespace] = module;
    }
    if (!isRoot && !hot) {
        const parentState = getNestedState(rootState, path.slice(0, -1));
        const moduleName = path[path.length - 1];
        store._withCommit(() => {
            parentState[moduleName] = module.state;
        });
    }
    const local = module.context = makeLocalContext(store, namespace, path);
    module.forEachMutation((mutation, key) => {
        const namespacedType = namespace + key;
        registerMutation(store, namespacedType, mutation, local);
    });
    module.forEachAction((action, key) => {
        const type = action.root ? key : namespace + key;
        const handler = action.handler || action;
        registerAction(store, type, handler, local);
    });
    module.forEachGetter((getter, key) => {
        const namespacedType = namespace + key;
        registerGetter(store, namespacedType, getter, local);
    });
    module.forEachChild((child, key) => {
        installModule(store, rootState, path.concat(key), child, hot);
    });
}
function makeLocalContext(store, namespace, path) {
    const noNamespace = namespace === '';
    const local = {
        dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) => {
            const args = unifyObjectStyle(_type, _payload, _options);
            const { payload, options } = args;
            let { type } = args;
            if (!options || !options.root) {
                type = namespace + type;
            }
            return store.dispatch(type, payload);
        },
        commit: noNamespace ? store.commit : (_type, _payload, _options) => {
            const args = unifyObjectStyle(_type, _payload, _options);
            const { payload, options } = args;
            let { type } = args;
            if (!options || !options.root) {
                type = namespace + type;
            }
            store.commit(type, payload, options);
        }
    };
    Object.defineProperties(local, {
        getters: {
            get: noNamespace
                ? () => store.getters
                : () => makeLocalGetters(store, namespace)
        },
        state: {
            get: () => getNestedState(store.state, path)
        }
    });
    return local;
}
function makeLocalGetters(store, namespace) {
    if (!store._makeLocalGettersCache[namespace]) {
        const gettersProxy = {};
        const splitPos = namespace.length;
        Object.keys(store.getters).forEach(type => {
            if (type.slice(0, splitPos) !== namespace)
                return;
            const localType = type.slice(splitPos);
            Object.defineProperty(gettersProxy, localType, {
                get: () => store.getters[type],
                enumerable: true
            });
        });
        store._makeLocalGettersCache[namespace] = gettersProxy;
    }
    return store._makeLocalGettersCache[namespace];
}
function registerMutation(store, type, handler, local) {
    const entry = store._mutations[type] || (store._mutations[type] = []);
    entry.push(function wrappedMutationHandler(payload) {
        handler.call(store, local.state, payload);
    });
}
function registerAction(store, type, handler, local) {
    const entry = store._actions[type] || (store._actions[type] = []);
    entry.push(function wrappedActionHandler(payload) {
        let res = handler.call(store, {
            dispatch: local.dispatch,
            commit: local.commit,
            getters: local.getters,
            state: local.state,
            rootGetters: store.getters,
            rootState: store.state
        }, payload);
        if (!isPromise(res)) {
            res = Promise.resolve(res);
        }
        if (store._devtoolHook) {
            return res.catch((err) => {
                store._devtoolHook.emit('vuex:error', err);
                throw err;
            });
        }
        else {
            return res;
        }
    });
}
function registerGetter(store, type, rawGetter, local) {
    if (store._wrappedGetters[type]) {
        return;
    }
    store._wrappedGetters[type] = function wrappedGetter(store) {
        return rawGetter(local.state, local.getters, store.state, store.getters);
    };
}
function enableStrictMode(store) {
    tenonVue.watch(() => store._state.data, () => {
    }, { deep: true, flush: 'sync' });
}
function getNestedState(state, path) {
    return path.reduce((state, key) => state[key], state);
}
function unifyObjectStyle(type, payload, options) {
    if (isObject$1(type) && type.type) {
        options = payload;
        payload = type;
        type = type.type;
    }
    return { type, payload, options };
}

const mapState = normalizeNamespace((namespace, states) => {
    const res = {};
    normalizeMap(states).forEach(({ key, val }) => {
        res[key] = function mappedState() {
            let state = this.$store.state;
            let getters = this.$store.getters;
            if (namespace) {
                const module = getModuleByNamespace(this.$store, 'mapState', namespace);
                if (!module) {
                    return;
                }
                state = module.context.state;
                getters = module.context.getters;
            }
            return typeof val === 'function'
                ? val.call(this, state, getters)
                : state[val];
        };
        res[key].vuex = true;
    });
    return res;
});
const mapMutations = normalizeNamespace((namespace, mutations) => {
    const res = {};
    normalizeMap(mutations).forEach(({ key, val }) => {
        res[key] = function mappedMutation(...args) {
            let commit = this.$store.commit;
            if (namespace) {
                const module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
                if (!module) {
                    return;
                }
                commit = module.context.commit;
            }
            return typeof val === 'function'
                ? val.apply(this, [commit].concat(args))
                : commit.apply(this.$store, [val].concat(args));
        };
    });
    return res;
});
const mapGetters = normalizeNamespace((namespace, getters) => {
    const res = {};
    normalizeMap(getters).forEach(({ key, val }) => {
        val = namespace + val;
        res[key] = function mappedGetter() {
            if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
                return;
            }
            return this.$store.getters[val];
        };
        res[key].vuex = true;
    });
    return res;
});
const mapActions = normalizeNamespace((namespace, actions) => {
    const res = {};
    normalizeMap(actions).forEach(({ key, val }) => {
        res[key] = function mappedAction(...args) {
            let dispatch = this.$store.dispatch;
            if (namespace) {
                const module = getModuleByNamespace(this.$store, 'mapActions', namespace);
                if (!module) {
                    return;
                }
                dispatch = module.context.dispatch;
            }
            return typeof val === 'function'
                ? val.apply(this, [dispatch].concat(args))
                : dispatch.apply(this.$store, [val].concat(args));
        };
    });
    return res;
});
const createNamespacedHelpers = (namespace) => ({
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
});
function normalizeMap(map) {
    if (!isValidMap(map)) {
        return [];
    }
    return Array.isArray(map)
        ? map.map(key => ({ key, val: key }))
        : Object.keys(map).map(key => ({ key, val: map[key] }));
}
function isValidMap(map) {
    return Array.isArray(map) || isObject$1(map);
}
function normalizeNamespace(fn) {
    return (namespace, map) => {
        if (typeof namespace !== 'string') {
            map = namespace;
            namespace = '';
        }
        else if (namespace.charAt(namespace.length - 1) !== '/') {
            namespace += '/';
        }
        return fn(namespace, map);
    };
}
function getModuleByNamespace(store, helper, namespace) {
    const module = store._modulesNamespaceMap[namespace];
    return module;
}

function createLogger({ collapsed = true, filter = (mutation, stateBefore, stateAfter) => true, transformer = (state) => state, mutationTransformer = (mut) => mut, actionFilter = (action, state) => true, actionTransformer = (act) => act, logMutations = true, logActions = true, logger = console } = {}) {
    return (store) => {
        let prevState = deepCopy(store.state);
        if (typeof logger === 'undefined') {
            return;
        }
        if (logMutations) {
            store.subscribe((mutation, state) => {
                const nextState = deepCopy(state);
                if (filter(mutation, prevState, nextState)) {
                    const formattedTime = getFormattedTime();
                    const formattedMutation = mutationTransformer(mutation);
                    const message = `mutation ${mutation.type}${formattedTime}`;
                    startMessage(logger, message, collapsed);
                    logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
                    logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
                    logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
                    endMessage(logger);
                }
                prevState = nextState;
            });
        }
        if (logActions) {
            store.subscribeAction((action, state) => {
                if (actionFilter(action, state)) {
                    const formattedTime = getFormattedTime();
                    const formattedAction = actionTransformer(action);
                    const message = `action ${action.type}${formattedTime}`;
                    startMessage(logger, message, collapsed);
                    logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
                    endMessage(logger);
                }
            });
        }
    };
}
function startMessage(logger, message, collapsed) {
    const startMessage = collapsed
        ? logger.groupCollapsed
        : logger.group;
    try {
        startMessage.call(logger, message);
    }
    catch (e) {
        logger.log(message);
    }
}
function endMessage(logger) {
    try {
        logger.groupEnd();
    }
    catch (e) {
        logger.log('—— log end ——');
    }
}
function getFormattedTime() {
    const time = new Date();
    return ` @ ${pad(time.getHours(), 2)}:${pad(time.getMinutes(), 2)}:${pad(time.getSeconds(), 2)}.${pad(time.getMilliseconds(), 3)}`;
}
function repeat(str, times) {
    return (new Array(times + 1)).join(str);
}
function pad(num, maxLength) {
    return repeat('0', maxLength - num.toString().length) + num;
}

var OperationType;
(function (OperationType) {
    OperationType[OperationType["ADD"] = 0] = "ADD";
    OperationType[OperationType["DELETE"] = 1] = "DELETE";
    OperationType[OperationType["UPDATE"] = 2] = "UPDATE";
})(OperationType || (OperationType = {}));

const NAMESPACE = Hummer.env.namespace || '';
const randomChars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function diff(left, right, parentKey = []) {
    let ops = [];
    Object.keys(left).forEach(key => {
        if (!right.hasOwnProperty(key)) {
            ops.push(createOperation(OperationType.DELETE, [...parentKey, key]));
            return;
        }
        if (isObject(left[key]) && isObject(right[key])) {
            if (!isEqual(left[key], right[key])) {
                ops.push(createOperation(OperationType.UPDATE, [...parentKey, key], right[key]));
            }
        }
        else {
            if (left[key] !== right[key]) {
                ops.push(createOperation(OperationType.UPDATE, [...parentKey, key], right[key]));
            }
        }
    });
    Object.keys(right).forEach(key => {
        if (!left.hasOwnProperty(key)) {
            ops.push(createOperation(OperationType.ADD, [...parentKey, key], right[key]));
        }
    });
    return ops;
}
function createOperation(type, key, value) {
    return {
        type: type,
        key: key,
        value: value
    };
}
function isObject(x) {
    return Object(x) === x;
}
function isEqual(left, right) {
    return left === right;
}
function cloneObject(source) {
    return Object.assign({}, source);
}
function getUUID() {
    const id = randomString(8, randomChars);
    return id;
}
function getNotifyEventKey(customKey) {
    return `${customKey || NAMESPACE}_UPDATE_STORE`;
}
function getMemoryKey(customKey) {
    return `${customKey || NAMESPACE}_STORE_MEMORY`;
}
function randomString(length = 8, chars) {
    var result = '';
    for (var i = length; i > 0; --i)
        result += chars[Math.floor(Math.random() * chars.length)];
    return result;
}
const Undefined = Symbol('undefined');
const StaicUndefined = 'undefined';
function stringify(obj) {
    return JSON.stringify(obj, (key, value) => {
        if (value === undefined) {
            return StaicUndefined;
        }
        return value;
    });
}
function parseJson(json) {
    let obj = JSON.parse(json, (key, value) => {
        if (value === StaicUndefined) {
            return Undefined;
        }
        return value;
    });
    Object.keys(obj).forEach((key) => {
        if (obj[key] === Undefined) {
            obj[key] = undefined;
        }
    });
    return obj;
}
function setMemoryByKey(key, content) {
    Memory.set(key, 'Memory_' + content);
}
function getMemoryByKey(key) {
    let data = Memory.get(key);
    if (data) {
        if (!data.startsWith('Memory_')) {
            return data;
        }
    }
    return data && data.slice(7);
}

const id = getUUID();
let cacheData = {};
function createHummerPlugin({ store_key } = {}) {
    const MemoryStoreKey = getMemoryKey(store_key);
    const NotifyEvent = getNotifyEventKey(store_key);
    return (store) => {
        initState(store, MemoryStoreKey);
        let notifyCenter = Hummer.notifyCenter;
        notifyCenter.addEventListener(NotifyEvent, ({ eventId, operations }) => {
            if (eventId === id) {
                return;
            }
            if (typeof operations === 'string') {
                operations = JSON.parse(operations);
            }
            resetStore(store, operations);
            cacheData = cloneObject(store.state);
        });
        store.subscribe((mutation, state) => {
            setMemoryByKey(MemoryStoreKey, stringify(state));
            let ops = diff(cacheData, state);
            if (!ops || ops.length === 0) {
                return;
            }
            notifyCenter.triggerEvent(NotifyEvent, {
                eventId: id,
                operations: JSON.stringify(ops)
            });
            cacheData = cloneObject(state);
        });
    };
}
function initState(store, MemoryStoreKey) {
    let newData = getMemoryByKey(MemoryStoreKey);
    if (newData) {
        newData = parseJson(newData);
        cacheData = cloneObject(newData);
        store.replaceState(newData);
    }
}
function setObjectValue(ob, keys, value) {
    let temp = ob;
    let lastKey = keys.pop();
    keys.forEach((key, index) => {
        temp = temp[key];
    });
    temp && lastKey && (temp[lastKey] = value);
}
function resetStore(store, operations) {
    operations.forEach(operation => {
        updateStore(store, operation);
    });
}
function updateStore(store, operation) {
    let { type, key, value } = operation;
    store._withCommit(() => {
        switch (type) {
            case OperationType.ADD:
                setObjectValue(store.state, key, value);
                break;
            case OperationType.DELETE:
                setObjectValue(store.state, key, undefined);
                break;
            case OperationType.UPDATE:
                setObjectValue(store.state, key, value);
                break;
        }
    });
}

var index = {
    createStore,
    Store,
    useStore,
    mapState,
    mapMutations,
    mapGetters,
    mapActions,
    createNamespacedHelpers,
    createLogger,
    createHummerPlugin
};

exports.Store = Store;
exports.createHummerPlugin = createHummerPlugin;
exports.createLogger = createLogger;
exports.createNamespacedHelpers = createNamespacedHelpers;
exports.createStore = createStore;
exports['default'] = index;
exports.mapActions = mapActions;
exports.mapGetters = mapGetters;
exports.mapMutations = mapMutations;
exports.mapState = mapState;
exports.useStore = useStore;
//# sourceMappingURL=tenon-store.cjs.js.map
