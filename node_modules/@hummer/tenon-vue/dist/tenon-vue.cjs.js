'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var runtimeCore = require('@vue/runtime-core');
var tenonUtils = require('@hummer/tenon-utils');
var shared = require('@vue/shared');

const ViewCache = new Map();
const FixedViewCache = new Map();
const setCacheNode = (node) => {
    ViewCache.set(node.__view_id, node);
};
const deleteCacheNode = (node) => {
    ViewCache.delete(node.__view_id);
};
const handleFixedNodeByStyle = (node, newStyle) => {
    let oldPosition = node.style.position;
    let newPosition = newStyle.position;
    if (newPosition === 'fixed') {
        registerFixedNode(node);
        return true;
    }
    if (oldPosition === 'fixed' && newPosition !== 'fixed') {
        unRegisterFixedNode(node);
        return false;
    }
    return false;
};
const registerFixedNode = (node) => {
    let fixedNode = {
        id: node.__view_id,
        parents: node.parent ? getParentIds(node.__view_id) : null
    };
    FixedViewCache.set(node.__view_id, fixedNode);
};
const unRegisterFixedNode = (node) => {
    let { __view_id: id } = node;
    FixedViewCache.delete(id);
};
const removeChildWithFixed = (node) => {
    let { __view_id } = node;
    FixedViewCache.forEach((fixedNode) => {
        let { id, parents } = fixedNode;
        if (fixedNode.parents === null) {
            parents = fixedNode.parents = getParentIds(id);
        }
        if (parents && parents.has(__view_id)) {
            deleteNodeByViewId(id);
        }
        if (id === __view_id) {
            FixedViewCache.delete(id);
        }
    });
    deleteCacheNode(node);
};
function getParentIds(id) {
    let ids = new Set();
    let node = ViewCache.get(id);
    while (node) {
        if (node.parent) {
            ids.add(node.parent.__view_id);
        }
        node = node.parent;
    }
    return ids;
}
function deleteNodeByViewId(id) {
    let node = ViewCache.get(id);
    if (node && node.parent) {
        node.parent._removeChild(node);
    }
    FixedViewCache.delete(id);
}

let animationId = 0;
var EasingType;
(function (EasingType) {
    EasingType["LINEAR"] = "linear";
    EasingType["EASE"] = "ease";
    EasingType["EASE_IN"] = "ease-in";
    EasingType["EASE_OUT"] = "ease-out";
    EasingType["EASE_IN_OUT"] = "ease-in-out";
})(EasingType || (EasingType = {}));
var AnimationStyle;
(function (AnimationStyle) {
    AnimationStyle["POSITION"] = "position";
    AnimationStyle["SCALE"] = "scale";
    AnimationStyle["SCALEX"] = "scaleX";
    AnimationStyle["SCALEY"] = "scaleY";
    AnimationStyle["ROTATIONX"] = "rotationX";
    AnimationStyle["ROTATIONY"] = "rotationY";
    AnimationStyle["ROTATIONZ"] = "rotationZ";
    AnimationStyle["OPACITY"] = "opacity";
    AnimationStyle["BACKGROUND_COLOR"] = "backgroundColor";
    AnimationStyle["WIDTH"] = "width";
    AnimationStyle["HEIGHT"] = "height";
})(AnimationStyle || (AnimationStyle = {}));
function handleKeyframeAnimation(node, animation) {
    let { id, onEnd, onStart, keyframes, repeatCount = 1, duration, delay, easing = 'linear' } = animation;
    let { element } = node;
    let styles = keyframes[0].styles;
    styles = transformStyle(styles);
    let len = Object.keys(styles).length;
    if (!id) {
        id = animationId++;
    }
    Object.keys(styles).forEach((key, index) => {
        const ani = new __GLOBAL__.KeyframeAnimation(key);
        let tempKeyframes = [];
        keyframes.forEach(keyframe => {
            let transformedStyles = transformStyle(keyframe.styles);
            if (transformedStyles[key] !== undefined) {
                tempKeyframes.push({
                    percent: keyframe.percent,
                    value: transformedStyles[key]
                });
            }
        });
        ani.keyframes = tempKeyframes;
        easing && (ani.easing = easing);
        duration && (ani.duration = handleDuration(duration));
        delay && (ani.delay = handleDelay(delay));
        repeatCount && (ani.repeatCount = repeatCount);
        if (index === 0) {
            onStart && ani.on("start", () => {
                onStart && onStart();
            });
        }
        onEnd && ani.on("end", () => {
            if (--len <= 0) {
                onEnd && onEnd();
            }
        });
        element.addAnimation(ani, id + "_" + key);
    });
}
function handleBasicAnimation(node, animation) {
    let { styles, id, duration, delay, repeatCount, easing, onStart, onEnd } = animation;
    let { element } = node;
    styles = transformStyle(styles);
    if (!id) {
        id = animationId++;
    }
    let len = Object.keys(styles).length;
    Object.keys(styles).forEach((key, index) => {
        const ani = new __GLOBAL__.BasicAnimation(key);
        ani.value = styles[key];
        easing && (ani.easing = easing);
        !isNaN(duration) && (ani.duration = handleDuration(duration));
        !isNaN(delay) && (ani.delay = handleDelay(delay));
        !isNaN(repeatCount) && (ani.repeatCount = repeatCount);
        if (index === 0) {
            onStart && ani.on("start", () => {
                onStart && onStart();
            });
        }
        onEnd && ani.on("end", () => {
            if (--len <= 0) {
                onEnd && onEnd();
            }
        });
        element.addAnimation(ani, id + "_" + key);
    });
}
function handleStepAnimation(node, animation) {
    let { id, onEnd, onStart, steps } = animation;
    let current = Promise.resolve();
    steps && steps.forEach((step, index) => {
        let _onStart;
        let _onEnd;
        current = current.then(() => {
            return new Promise((resolve) => {
                if (index === 0) {
                    _onStart = () => {
                        step.onStart && step.onStart();
                        onStart && onStart();
                    };
                }
                if (index === steps.length - 1) {
                    _onEnd = () => {
                        step.onEnd && step.onEnd();
                        onEnd && onEnd();
                    };
                }
                else {
                    _onEnd = () => {
                        step.onEnd && step.onEnd();
                        resolve();
                    };
                }
                handleBasicAnimation(node, Object.assign(Object.assign({}, step), { id: id + "_" + index, onStart: _onStart, onEnd: _onEnd }));
            });
        });
    });
}
function transformStyle(styles) {
    Object.keys(styles).forEach(key => {
        switch (key) {
            case AnimationStyle.POSITION:
                let position = styles[key];
                styles[key] = {
                    x: tenonUtils.transformUnitValue(position.x),
                    y: tenonUtils.transformUnitValue(position.y)
                };
                break;
            case AnimationStyle.BACKGROUND_COLOR:
                styles[key] = tenonUtils.getColor(styles[key]);
                break;
            case AnimationStyle.WIDTH:
                styles[key] = tenonUtils.transformUnitValue(styles[key]);
                break;
            case AnimationStyle.HEIGHT:
                styles[key] = tenonUtils.transformUnitValue(styles[key]);
                break;
        }
    });
    return styles;
}
function handleDuration(duration) {
    return duration / 1000;
}
function handleDelay(delay) {
    return delay / 1000;
}
const handleAnimation = (context, animation) => {
    if (animation.keyframes) {
        handleKeyframeAnimation(context, animation);
    }
    if (animation.styles) {
        handleBasicAnimation(context, animation);
    }
    if (animation.steps) {
        handleStepAnimation(context, animation);
    }
};

exports.MatchType = void 0;
(function (MatchType) {
    MatchType[MatchType["Class"] = 0] = "Class";
    MatchType[MatchType["ID"] = 1] = "ID";
    MatchType[MatchType["Attr"] = 2] = "Attr";
    MatchType[MatchType["Tag"] = 3] = "Tag";
})(exports.MatchType || (exports.MatchType = {}));
const RuleKeyMap = {
    'tagList': 'tagMap',
    'classList': 'classMap',
    'idList': 'idMap'
};
exports.RelationType = void 0;
(function (RelationType) {
    RelationType[RelationType["Subselector"] = 0] = "Subselector";
    RelationType[RelationType["DescendantSpace"] = 1] = "DescendantSpace";
    RelationType[RelationType["Child"] = 2] = "Child";
    RelationType[RelationType["DirectAdjacent"] = 3] = "DirectAdjacent";
    RelationType[RelationType["IndirectAdjacent"] = 4] = "IndirectAdjacent";
})(exports.RelationType || (exports.RelationType = {}));
const collectStyle = function (ruleSetMap) {
    if (!__GLOBAL__.CSSOM) {
        const defaultRuleSetGroup = {
            global: {
                tagMap: new Map(),
                classMap: new Map(),
                idMap: new Map()
            }
        };
        __GLOBAL__.CSSOM = defaultRuleSetGroup;
    }
    Object.keys(ruleSetMap).forEach((group) => {
        let ruleSet = ruleSetMap[group];
        collectStyleGroup(ruleSet, group);
    });
};
const collectStyleGroup = function (ruleSet, group) {
    if (!__GLOBAL__.CSSOM[group]) {
        const defaultRuleSet = {
            tagMap: new Map(),
            classMap: new Map(),
            idMap: new Map()
        };
        __GLOBAL__.CSSOM[group] = defaultRuleSet;
    }
    Object.keys(ruleSet).forEach((ruleKey) => {
        let ruleList = ruleSet[ruleKey];
        let key = RuleKeyMap[ruleKey];
        key && ruleList.forEach((rule) => {
            if (rule) {
                let selectorMap = __GLOBAL__.CSSOM[group][key];
                let selectorKey = rule.selector;
                let styleList = selectorMap.get(selectorKey) || [];
                styleList.push(rule);
                __GLOBAL__.CSSOM[group][key].set(selectorKey, styleList);
            }
        });
    });
};
const getClassStyle = function (instance, className = '', scoped = false, scopedId) {
    let elementStyle = {};
    const classList = className.split(/\s/);
    classList.forEach((item) => {
        if (!item) {
            return;
        }
        let globalStyleArr = getGlobalStyle(exports.MatchType.Class, item, filterStyle(classList));
        let scopeStylesArr = [];
        if (scoped && scopedId) {
            scopeStylesArr = getScopedStyle(exports.MatchType.Class, item, scopedId, filterStyle(classList));
        }
        elementStyle = Object.assign({}, elementStyle, ...globalStyleArr, ...scopeStylesArr);
    });
    return elementStyle;
};
function filterStyle(classList = []) {
    return (rule) => {
        if (rule.relation === '') {
            return true;
        }
        let flag = true;
        let selector = rule.n_selector;
        if (!selector.next) {
            return true;
        }
        switch (selector.relation) {
            case exports.RelationType.Subselector:
                while (selector) {
                    if (classList.indexOf(selector.value) < 0) {
                        flag = false;
                        break;
                    }
                    selector = selector.next;
                }
                break;
        }
        return flag;
    };
}
function getGlobalStyle(type, key, filterFunc) {
    let styles = [];
    switch (type) {
        case exports.MatchType.Class:
            styles = __GLOBAL__.CSSOM['global'].classMap.get(key) || [];
            break;
    }
    return styles.filter((item) => {
        if (filterFunc) {
            return filterFunc(item);
        }
        return item;
    }).map((item) => {
        return item === null || item === void 0 ? void 0 : item.style;
    });
}
function getScopedStyle(type, key, scopedId, filterFunc) {
    let styles = [];
    const { CSSOM } = __GLOBAL__;
    if (CSSOM[scopedId]) {
        switch (type) {
            case exports.MatchType.Class:
                styles = CSSOM[scopedId].classMap.get(key) || [];
                break;
        }
    }
    return styles.filter((item) => {
        if (filterFunc) {
            return filterFunc(item);
        }
        return item;
    }).map((item) => {
        return item === null || item === void 0 ? void 0 : item.style;
    });
}

let __view_id = 0;
class Base {
    constructor() {
        this._scopedIds = new Set();
        this.__NAME = null;
        this.element = null;
        this.dataset = {};
        this.children = new Set();
        this.parent = undefined;
        this.firstChild = null;
        this.lastChild = null;
        this.prevSibling = null;
        this.nextSibling = null;
        this.props = new Map();
        this.__view_id = 0;
        this._defaultStyle = {};
        this._style = {};
        this._baseStyle = {};
        this.__view_id = __view_id++;
        setCacheNode(this);
    }
    get disabled() {
        return !this.element.enabled;
    }
    set disabled(disabled) {
        this.element.enabled = !disabled;
    }
    get style() {
        return this._style || {};
    }
    get className() {
        return this.props.get('class');
    }
    set style(value) {
        this.setStyle(value, true);
    }
    setScopeId(id) {
        this._scopedIds.add(id);
        this.updateStyle();
    }
    updateStyle() {
        if (!this._scopedIds.size) {
            return;
        }
        let className = this.getAttribute('class');
        this._scopedIds.forEach(scopedId => {
            let elementStyle = getClassStyle(this, className, true, scopedId);
            if (Object.keys(elementStyle).length > 0) {
                this.setStyle(elementStyle);
            }
        });
    }
    _onMounted() {
        this.onMounted();
    }
    onMounted() {
    }
    _onDestoryed() {
        removeChildWithFixed(this);
        this.onDestoryed();
    }
    onDestoryed() { }
    _appendChild(child) {
        child.unlinkSiblings();
        child.parent = this;
        this.children.add(child);
        if (!this.firstChild) {
            this.firstChild = child;
        }
        child.prevSibling = this.lastChild;
        child.nextSibling = null;
        if (this.lastChild) {
            this.lastChild.nextSibling = child;
        }
        this.lastChild = child;
        if (this.element && child.element) {
            this.element.appendChild(child.element);
        }
        child._onMounted();
    }
    unlinkSiblings() {
        if (this.parent && this.parent.firstChild === this) {
            this.parent.firstChild = this.nextSibling;
        }
        if (this.parent && this.parent.lastChild === this) {
            this.parent.lastChild = this.prevSibling;
        }
        if (this.prevSibling) {
            this.prevSibling.nextSibling = this.nextSibling;
        }
        if (this.nextSibling) {
            this.nextSibling.prevSibling = this.prevSibling;
        }
        this.prevSibling = null;
        this.nextSibling = null;
    }
    _removeChild(child) {
        child._onDestoryed();
        child.unlinkSiblings();
        child.parent = undefined;
        this.children.delete(child);
        if (this.element && child.element) {
            this.element.removeChild(child.element);
        }
    }
    _insertBefore(child, anchor) {
        child.unlinkSiblings();
        child.parent = this;
        if (anchor.prevSibling) {
            child.prevSibling = anchor.prevSibling;
            anchor.prevSibling.nextSibling = child;
        }
        anchor.prevSibling = child;
        child.nextSibling = anchor;
        if (this.firstChild === anchor) {
            this.firstChild = child;
        }
        this.children.add(child);
        if (this.element && child.element && anchor.element) {
            this.element.insertBefore(child.element, anchor.element);
            child._onMounted();
        }
    }
    setElementText(text) {
    }
    setStyle(style, flag = false) {
        let tempStyle = this.hackForStyle(style, this);
        flag && (this._baseStyle = tempStyle);
        let newStyle = Object.assign(Object.assign(Object.assign({}, this._defaultStyle), tempStyle), this._baseStyle);
        handleFixedNodeByStyle(this, newStyle);
        this.element.style = this._style = newStyle;
    }
    hackForStyle(style, base) {
        return tenonUtils.styleDynamicTransformer.transformStyle(style, base);
    }
    setAttribute(key, value) {
        this.setCacheProp(key, value);
        switch (key) {
            case 'disabled':
                this.disabled = value !== false;
                break;
            case 'class':
                this.updateStyle();
                break;
            default:
                this._setAttribute(key, value);
                break;
        }
    }
    setCacheProp(key, value) {
        if (/^data/.test(key)) {
            let dataKey = key.slice(4).toLowerCase();
            if (dataKey) {
                this.dataset[dataKey] = value;
            }
        }
        this.props.set(key, value);
    }
    _setAttribute(key, value) {
    }
    getAttribute(key) {
        switch (key) {
            case 'disabled':
                return this.disabled;
            default:
                return this.props.get(key);
        }
    }
    handleAnimation(animation) {
        handleAnimation(this, animation);
    }
    addEventListener(event, func) {
        this.element.addEventListener(event, (e) => {
            e.target = {
                dataset: this.dataset
            };
            func.call(this, e);
        });
    }
    removeEventListener(event, func) {
        this.element.removeEventListener(event, func);
    }
    getRect(func) {
        this.element.getRect((rect) => {
            func.call(this, rect);
        });
    }
}

const noFunc = () => { };
class RootViewComponent extends __GLOBAL__.View {
    constructor(options = {}) {
        super();
        this._element = null;
        this._canScroll = true;
        let { onLoad, onShow, onHide, onUnload, onBack, canScroll = true, pageStyle = {} } = options;
        this._onCreate = onLoad || noFunc;
        this._onAppear = onShow || noFunc;
        this._onDisappear = onHide || noFunc;
        this._onDestroy = onUnload || noFunc;
        this._onBack = onBack || noFunc;
        this._canScroll = canScroll;
        this.style = Object.assign(Object.assign({}, pageStyle), { width: '100%', height: '100%' });
        if (this._canScroll) {
            this._element = new __GLOBAL__.Scroller();
            this._element.style = {
                width: "100%",
                height: "100%",
            };
            this.appendChild(this._element);
        }
    }
    get element() {
        return this._canScroll && this._element ? this._element : this;
    }
    onCreate() {
        this._onCreate();
    }
    onAppear() {
        this._onAppear();
    }
    onDisappear() {
        this._onDisappear();
    }
    onDestroy() {
        this._onDestroy();
    }
    onBack() {
        let result = this._onBack();
        return result || false;
    }
}
class Page extends Base {
    constructor(options) {
        super();
        this._rootView = new RootViewComponent(options);
        this.element = this._rootView.element;
    }
    render() {
        __GLOBAL__.Hummer.render(this._rootView);
    }
    set onLoad(load) {
        this._rootView._onCreate = load;
    }
    set onShow(show) {
        this._rootView._onAppear = show;
    }
    set onHide(hide) {
        this._rootView._onDisappear = hide;
    }
    set onUnload(destroy) {
        this._rootView._onDestroy = destroy;
    }
    set onBack(back) {
        this._rootView._onBack = back;
    }
}

class View extends Base {
    constructor(isView = true) {
        super();
        this.__NAME = tenonUtils.NODE_VIEW;
        if (!isView) {
            return;
        }
        this.element = new __GLOBAL__.View();
    }
}

class Text extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_TEXT;
        this._text = '';
        this.element = new __GLOBAL__.Text();
    }
    setElementText(text) {
        this._text = text;
        this.element.text = text;
        this.parent && (this.parent.__NAME === tenonUtils.NODE_TEXT) && this.parent.setElementText(this.parent.getInnerText());
    }
    getInnerText() {
        let innerText = '';
        this.children.forEach(child => {
            innerText += (child && child._text || '');
        });
        return innerText;
    }
    _appendChild(child) {
        child.unlinkSiblings();
        child.parent = this;
        this.children.add(child);
        if (!this.firstChild) {
            this.firstChild = child;
        }
        child.prevSibling = this.lastChild;
        child.nextSibling = null;
        if (this.lastChild) {
            this.lastChild.nextSibling = child;
        }
        this.lastChild = child;
        if (this.element && child.element) {
            this.setElementText(this.getInnerText());
        }
        child._onMounted();
    }
    _insertBefore(child, anchor) {
        child.unlinkSiblings();
        child.parent = this;
        if (anchor.prevSibling) {
            child.prevSibling = anchor.prevSibling;
            anchor.prevSibling.nextSibling = child;
        }
        anchor.prevSibling = child;
        child.nextSibling = anchor;
        if (this.firstChild === anchor) {
            this.firstChild = child;
        }
        this.children.add(child);
        if (this.element && child.element && anchor.element) {
            this.setElementText(this.getInnerText());
            child._onMounted();
        }
    }
    _removeChild(child) {
        child._onDestoryed();
        child.unlinkSiblings();
        child.parent = undefined;
        this.children.delete(child);
        if (this.element && child.element) {
            this.setElementText(this.getInnerText());
        }
    }
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
        this.element.text = text;
    }
    set richText(value) {
        this.element.richText = value;
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'richText':
                this.richText = value;
                break;
        }
    }
}

var ImageAttr;
(function (ImageAttr) {
    ImageAttr["Src"] = "src";
    ImageAttr["GifCount"] = "gifRepeatCount";
    ImageAttr["Resize"] = "resize";
})(ImageAttr || (ImageAttr = {}));
const gifReg = /\.gif$/;
class Image extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_IMAGE;
        this._src = '';
        this.element = new __GLOBAL__.Image();
        this.element.style = {
            resize: 'stretch'
        };
    }
    set src(value) {
        if (gifReg.test(value)) {
            this.element.gifSrc = value;
        }
        else {
            this.element.src = value;
        }
        this._src = value;
    }
    _setAttribute(key, value) {
        switch (key) {
            case ImageAttr.Src:
                this.src = value;
                break;
            case ImageAttr.GifCount:
                this.element.gifRepeatCount = Number(value);
                this.src = this._src;
                break;
            case ImageAttr.Resize:
                this.style = {
                    resize: value
                };
                break;
        }
    }
}

class Input extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_INPUT;
        this._input = null;
        this._change = null;
        this._focus = null;
        this._blur = null;
        this._confirm = null;
        this._hasInput = false;
        this.element = new __GLOBAL__.Input();
    }
    get value() {
        return this.element.text || '';
    }
    set value(value) {
        this.element.text = value;
    }
    get focused() {
        return this.element.focused || false;
    }
    set focused(value) {
        this.element.focused = value !== false;
    }
    get placeholder() {
        return this.element.placeholder || '';
    }
    set placeholder(text) {
        this.element.placeholder = text;
    }
    set type(value) {
        this.element.style = {
            type: value
        };
    }
    set returnKeyType(value) {
        this.element.style = {
            returnKeyType: value
        };
    }
    set maxLength(value) {
        this.element.style = {
            maxLength: value
        };
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'value':
                this.value = value;
                break;
            case 'placeholder':
                this.placeholder = value;
                break;
            case 'focused':
                this.focused = value;
                break;
            case 'type':
                this.type = value;
                break;
            case 'maxLength':
                this.maxLength = value;
                break;
            case 'returnKeyType':
                this.returnKeyType = value;
                break;
        }
    }
    addEventListener(event, func) {
        var handler = (text) => {
            func.call(this, text);
        };
        switch (event) {
            case 'input':
                this._input = handler;
                break;
            case 'change':
                this._change = handler;
                break;
            case 'focus':
                this._focus = handler;
                break;
            case 'blur':
                this._blur = handler;
                break;
            case 'confirm':
                this._confirm = handler;
                break;
        }
        this.initListener();
    }
    removeEventListener(event) {
        switch (event) {
            case 'input':
                this._input = null;
                this._hasInput = false;
                break;
            case 'change':
                this._change = null;
                break;
            case 'focus':
                this._focus = null;
                break;
            case 'blur':
                this._blur = null;
                break;
            case 'confirm':
                this._confirm = null;
                break;
        }
    }
    initListener() {
        if (this._hasInput) {
            return;
        }
        this.element.addEventListener('input', (event) => {
            let { state, text } = event;
            switch (state) {
                case 1:
                    this._focus && this._focus(text);
                    break;
                case 2:
                    this._change && this._change(text);
                    break;
                case 3:
                    this._blur && this._blur(text);
                    break;
                case 4:
                    this._confirm && this._confirm(text);
                    break;
            }
            this._input && this._input({ value: text, text: text, state });
        });
        this._hasInput = true;
    }
}

class TextArea extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_TEXTAREA;
        this._input = null;
        this._change = null;
        this._focus = null;
        this._blur = null;
        this._confirm = null;
        this._hasInput = false;
        this.element = new __GLOBAL__.TextArea();
    }
    get value() {
        return this.element.text || '';
    }
    set value(value) {
        this.element.text = value;
    }
    get focused() {
        return this.element.focused || false;
    }
    set focused(value) {
        this.element.focused = value !== false;
    }
    get placeholder() {
        return this.element.placeholder || '';
    }
    set placeholder(text) {
        this.element.placeholder = text;
    }
    set type(value) {
        this.element.style = {
            type: value
        };
    }
    set returnKeyType(value) {
        this.element.style = {
            returnKeyType: value
        };
    }
    set maxLength(value) {
        this.element.style = {
            maxLength: value
        };
    }
    set rows(value) {
        this.element.style = {
            textLineClamp: value
        };
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'value':
                this.value = value;
                break;
            case 'placeholder':
                this.placeholder = value;
                break;
            case 'focused':
                this.focused = value;
                break;
            case 'type':
                this.type = value;
                break;
            case 'maxLength':
                this.maxLength = value;
                break;
            case 'returnKeyType':
                this.returnKeyType = value;
                break;
            case 'rows':
                this.rows = value;
                break;
        }
    }
    addEventListener(event, func) {
        var handler = (text) => {
            func.call(this, text);
        };
        switch (event) {
            case 'input':
                this._input = handler;
                break;
            case 'change':
                this._change = handler;
                break;
            case 'focus':
                this._focus = handler;
                break;
            case 'blur':
                this._blur = handler;
                break;
            case 'confirm':
                this._confirm = handler;
                break;
        }
        this.initListener();
    }
    removeEventListener(event) {
        switch (event) {
            case 'input':
                this._input = null;
                this._hasInput = false;
                break;
            case 'change':
                this._change = null;
                break;
            case 'focus':
                this._focus = null;
                break;
            case 'blur':
                this._blur = null;
                break;
            case 'confirm':
                this._confirm = null;
                break;
        }
    }
    initListener() {
        if (this._hasInput) {
            return;
        }
        this.element.addEventListener('input', (event) => {
            let { state, text } = event;
            switch (state) {
                case 1:
                    this._focus && this._focus(text);
                    break;
                case 2:
                    this._change && this._change(text);
                    break;
                case 3:
                    this._blur && this._blur(text);
                    break;
                case 4:
                    this._confirm && this._confirm(text);
                    break;
            }
            this._input && this._input({ value: text, text: text, state });
        });
        this._hasInput = true;
    }
}

class Button extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_BUTTON;
        this._text = '';
        this.element = new __GLOBAL__.Button();
    }
    setElementText(text) {
        this.text = text;
    }
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
        this.element.text = text;
    }
    set pressedStyle(style) {
        this.element.pressed = tenonUtils.styleTransformer.transformStyle(style, this) || {};
    }
    set disabledStyle(style) {
        this.element.disabled = tenonUtils.styleTransformer.transformStyle(style, this) || {};
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'disabled':
                this.disabled = value;
                break;
            case 'disabledStyle':
                this.disabledStyle = value;
                break;
            case 'pressedStyle':
                this.pressedStyle = value;
                break;
        }
    }
}

class Comment extends Base {
    constructor(comment) {
        super();
        this.__NAME = tenonUtils.NODE_COMMENT;
        this._comment = '';
        this.element = new __GLOBAL__.View();
        this.element.style = {
            display: 'none'
        };
        this._comment = comment;
    }
    get comment() {
        return this._comment;
    }
}

class Scroller extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_SCROLLER;
        this.element = new __GLOBAL__.Scroller();
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'scrollDirection':
                if (value === 'horizontal' && this.element instanceof __GLOBAL__.Scroller) {
                    let scroller = new __GLOBAL__.HorizontalScroller();
                    scroller.style = this._style;
                    for (let child of this.children.values()) {
                        this.element.removeChild(child.element);
                        scroller.appendChild(child.element);
                    }
                    this.element = scroller;
                }
                break;
            case 'bounces':
                this.element.bounces = value !== false;
                break;
            case 'showScrollBar':
                this.element.showScrollBar = value !== false;
                break;
        }
    }
    _appendChild(child) {
        child.unlinkSiblings();
        child.parent = this;
        this.children.add(child);
        if (!this.firstChild) {
            this.firstChild = child;
        }
        child.prevSibling = this.lastChild;
        child.nextSibling = null;
        if (this.lastChild) {
            this.lastChild.nextSibling = child;
        }
        this.lastChild = child;
        if (this.element && child.element) {
            if (child.__NAME === tenonUtils.NODE_REFRESH) {
                this.element.refreshView = child.element;
            }
            else if (child.__NAME === tenonUtils.NODE_LOADMORE) {
                this.element.loadMoreView = child.element;
            }
            else {
                this.element.appendChild(child.element);
                child._onMounted();
            }
        }
    }
    _insertBefore(child, anchor) {
        child.unlinkSiblings();
        child.parent = this;
        if (anchor.prevSibling) {
            child.prevSibling = anchor.prevSibling;
            anchor.prevSibling.nextSibling = child;
        }
        anchor.prevSibling = child;
        child.nextSibling = anchor;
        if (this.firstChild === anchor) {
            this.firstChild = child;
        }
        this.children.add(child);
        if (this.element && child.element && anchor.element) {
            if (child.__NAME === tenonUtils.NODE_REFRESH) {
                this.element.refreshView = child.element;
            }
            else if (child.__NAME === tenonUtils.NODE_LOADMORE) {
                this.element.loadMoreView = child.element;
            }
            else {
                this.element.appendChild(child.element);
                child._onMounted();
            }
        }
    }
    scrollTo(x, y) {
        this.element.scrollTo(x, y);
    }
    scrollBy(dx, dy) {
        this.element.scrolBy(dx, dy);
    }
    scrollToTop() {
        this.element.scrollToTop();
    }
    scrollToBottom() {
        this.element.scrollToBottom();
    }
    stopPullRefresh() {
        this.element.stopPullRefresh();
    }
    stopLoadMore(enable) {
        this.element.stopLoadMore(enable);
    }
    addEventListener(event, func) {
        switch (event) {
            case "scroll":
                this.element.addEventListener('scroll', (e) => {
                    func.call(this, e);
                });
                break;
            case "scrolltotop":
                this.element.setOnScrollToTopListener(() => {
                    func.call(this);
                });
                break;
            case "scrolltobottom":
                this.element.setOnScrollToBottomListener(() => {
                    func.call(this);
                });
                break;
            case 'refresh':
                this.element.onRefresh = (state) => {
                    func.call(this, state, this);
                };
                break;
            case 'loadmore':
                this.element.onLoadMore = (state) => {
                    func.call(this, state, this);
                };
                break;
            default:
                this.element.addEventListener(event, (e) => {
                    func.call(this, e);
                });
                break;
        }
    }
}

class Anchor extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_ANCHOR;
        this.element = new __GLOBAL__.View();
        this.element.style = {
            display: "none"
        };
    }
}

class Switch extends Base {
    constructor() {
        super();
        this.__NAME = tenonUtils.NODE_SWITCH;
        this.element = new __GLOBAL__.Switch();
    }
    get value() {
        return this.element.checked;
    }
    set value(value) {
        this.element.checked = value !== false;
    }
    set onColor(value) {
        this.element.style = {
            onColor: value
        };
    }
    set offColor(value) {
        this.element.style = {
            offColor: value
        };
    }
    set thumbColor(value) {
        this.element.style = {
            thumbColor: value
        };
    }
    _setAttribute(key, value) {
        switch (key) {
            case 'value':
                this.value = value;
                break;
            case 'openColor':
                this.onColor = value;
                break;
            case 'closeColor':
                this.offColor = value;
                break;
            case 'thumbColor':
                this.thumbColor = value;
                break;
        }
    }
    addEventListener(event, func) {
        if (event === 'switch') {
            let invoker = (e) => {
                let { state } = e;
                let value = (state === 1 || state === true) ? true : false;
                func.call(this, value);
            };
            this.element.addEventListener(event, invoker);
        }
    }
    removeEventListener(event, func) {
        this.element.removeEventListener(event, func);
    }
}

class Refresh extends View {
    constructor() {
        super(...arguments);
        this.__NAME = tenonUtils.NODE_REFRESH;
    }
}

class LoadMore extends View {
    constructor() {
        super(...arguments);
        this.__NAME = tenonUtils.NODE_LOADMORE;
    }
}

const components = new Map();
function register(component) {
    if (Array.isArray(component)) {
        component.forEach((component) => {
            registerComponent(component);
        });
    }
    else {
        registerComponent(component);
    }
}
function registerComponent(component) {
    let { name } = component;
    components.set(`ex-${name}`, component);
}
function getComponent(tag) {
    let component = components.get(tag);
    return component.factory();
}

class Document {
    constructor() { }
    createElement(tag) {
        let component = null;
        switch (tag) {
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_VIEW]:
                component = new View();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_SCROLLER]:
                component = new Scroller();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_TEXT]:
                component = new Text();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_IMAGE]:
                component = new Image();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_INPUT]:
                component = new Input();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_TEXTAREA]:
                component = new TextArea();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_BUTTON]:
                component = new Button();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_SWITCH]:
                component = new Switch();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_LOADMORE]:
                component = new LoadMore();
                break;
            case tenonUtils.ELEMNT_TAG_MAP[tenonUtils.NODE_REFRESH]:
                component = new Refresh();
                break;
            default:
                if (tenonUtils.isCustomNativeTag(tag)) {
                    component = getComponent(tag) || new View();
                }
                else {
                    component = new View();
                }
                break;
        }
        return component;
    }
    createText(text) {
        let component = null;
        if (!text) {
            component = new Anchor();
        }
        else {
            component = new Text();
            component.setElementText(text);
        }
        return component;
    }
    createComment(comment) {
        return new Comment(comment);
    }
    createPageView(options) {
        let pageView = new Page(options);
        return pageView;
    }
}
var document = new Document();

const insert = function (child, parent, anchor) {
    if (!parent) {
        return null;
    }
    if (anchor !== null) {
        parent._insertBefore(child, anchor);
    }
    else {
        parent._appendChild(child);
    }
};
const remove = function (child) {
    const parent = child.parent;
    if (parent !== null) {
        parent._removeChild(child);
    }
};
const createElement = function (tag) {
    return document.createElement(tag);
};
const createText = function (text) {
    return document.createText(text);
};
const createComment = function (comment) {
    return document.createComment(comment);
};
const setText = function (node, text) {
    node.setElementText(text);
};
const setElementText = function (node, text) {
    node.setElementText(text);
};
const parentNode = function (node) {
    return node.parent ? node.parent : null;
};
const nextSibling = function (node) {
    return node.nextSibling;
};
const querySelector = function (selector) {
    return null;
};
const setScopeId = function (el, id) {
    el.setScopeId(id);
};
const nodeOps = {
    insert,
    remove,
    createElement,
    createText,
    createComment,
    setText,
    setElementText,
    parentNode,
    nextSibling,
    querySelector,
    setScopeId
};

function patchClass(el, key, prevValue, nextValue) {
    el.setAttribute(key, nextValue);
}

function patchStyle(el, key, prevValue, nextValue) {
    let style = nextValue;
    if (typeof nextValue === 'string') {
        style = tenonUtils.parseStringStyle(nextValue);
    }
    style = tenonUtils.styleTransformer.transformStyle(style, el);
    el.setStyle(style, true);
}

function patchAttrs(el, key, prevValue, nextValue) {
    el.setAttribute(key, nextValue);
}

const LongPress = 'longpress';
function patchEvents(el, rawName, prevValue, nextValue, instance = null) {
    const event = getStaticEventName(rawName);
    const value = nextValue;
    const invoker = prevValue && prevValue.invoker;
    if (nextValue && value) {
        if (invoker) {
            prevValue.invoker = null;
            invoker.value = value;
            nextValue.invoker = invoker;
        }
        else {
            addEventListener$1(el, event, createInvoker(value, instance));
        }
    }
    else if (invoker) {
        removeEventListener(el, event, invoker);
    }
}
function createInvoker(initialValue, instance) {
    const invoker = (...args) => {
        if (Array.isArray(initialValue)) {
            initialValue.forEach((func) => {
                func.apply(instance, [...args]);
            });
        }
        else {
            initialValue.apply(instance, [...args]);
        }
    };
    invoker.value = initialValue;
    initialValue.invoker = invoker;
    return invoker;
}
function addEventListener$1(el, event, handler) {
    el.addEventListener(event, handler);
}
function removeEventListener(el, event, handler) {
    el.removeEventListener(event, handler);
}
function getStaticEventName(rawName) {
    let eventName = rawName.slice(2).toLowerCase();
    if (eventName === LongPress) {
        eventName = "longPress";
    }
    return eventName;
}

function patchProp(el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    switch (key) {
        case 'class':
            patchClass(el, key, prevValue, nextValue);
            break;
        case 'style':
            patchStyle(el, key, prevValue, nextValue);
            break;
        default:
            if (isOn(key)) {
                patchEvents(el, key, prevValue, nextValue, parentComponent);
            }
            else {
                patchAttrs(el, key, prevValue, nextValue);
            }
            break;
    }
}
function isOn(key) {
    const onRE = /^on[^a-z]/;
    return onRE.test(key);
}

const context = {
    plugins: [],
    mixins: [],
    components: [],
    directives: [],
};
const use = (plugin, options) => {
    context.plugins.push({
        plugin: plugin,
        options: options
    });
};
const mixin = (mixin) => {
    context.mixins.push({
        mixin: mixin
    });
};
const component = (name, component) => {
    context.components.push({
        name: name,
        component: component
    });
};
const directive = (name, directive) => {
    context.directives.push({
        name: name,
        directive: directive
    });
};
const install = (app) => {
    context.plugins.forEach(item => {
        app.use(item.plugin, item.options);
    });
    context.mixins.forEach(item => {
        app.mixin(item.mixin);
    });
    context.components.forEach(item => {
        app.component(item.name, item.component);
    });
    context.directives.forEach(item => {
        app.directive(item.name, item.directive);
    });
};

var LifeCycleEnum;
(function (LifeCycleEnum) {
    LifeCycleEnum["ONLOAD"] = "onLoad";
    LifeCycleEnum["ONSHOW"] = "onShow";
    LifeCycleEnum["ONHIDE"] = "onHide";
    LifeCycleEnum["ONUNLOAD"] = "onUnload";
    LifeCycleEnum["ONBACK"] = "onBack";
})(LifeCycleEnum || (LifeCycleEnum = {}));
const LIFECYCLE = [LifeCycleEnum.ONLOAD, LifeCycleEnum.ONSHOW, LifeCycleEnum.ONHIDE, LifeCycleEnum.ONUNLOAD, LifeCycleEnum.ONBACK];
const initPageLifeCycle = (container, instance, config) => {
    let { mixins: globalMixins } = instance._.appContext;
    let { mixins, extends: extendOptions } = config;
    let lifeCycleMixins = {
        onLoad: [],
        onShow: [],
        onHide: [],
        onUnload: [],
        onBack: []
    };
    let globalLifeCycleMixins = {
        onLoad: [],
        onShow: [],
        onHide: [],
        onUnload: [],
        onBack: []
    };
    if (globalMixins) {
        globalLifeCycleMixins = applyPageMixin(globalMixins);
    }
    if (mixins) {
        lifeCycleMixins = applyPageMixin(mixins);
    }
    LIFECYCLE.forEach((lifecycle) => {
        if (lifecycle === LifeCycleEnum.ONBACK) {
            container[lifecycle] = () => {
                for (let i = 0; i < globalLifeCycleMixins[lifecycle].length; i++) {
                    if (applyLifeCycle(instance, globalLifeCycleMixins[lifecycle][i])) {
                        return true;
                    }
                }
                if (extendOptions) {
                    if (applyLifeCycle(instance, extendOptions[lifecycle])) {
                        return true;
                    }
                }
                for (let i = 0; i < lifeCycleMixins[lifecycle].length; i++) {
                    if (applyLifeCycle(instance, lifeCycleMixins[lifecycle][i])) {
                        return true;
                    }
                }
                return applyLifeCycle(instance, config[lifecycle]);
            };
            return true;
        }
        container[lifecycle] = () => {
            globalLifeCycleMixins[lifecycle].forEach((func) => {
                applyLifeCycle(instance, func);
            });
            extendOptions && applyLifeCycle(instance, extendOptions[lifecycle]);
            lifeCycleMixins[lifecycle].forEach((func) => {
                applyLifeCycle(instance, func);
            });
            applyLifeCycle(instance, config[lifecycle]);
        };
    });
};
function applyPageMixin(mixins) {
    let lifeCycleMixins = {
        onLoad: [],
        onShow: [],
        onHide: [],
        onUnload: [],
        onBack: []
    };
    if (!mixins || mixins.length === 0) {
        return lifeCycleMixins;
    }
    mixins.forEach((mixin) => {
        let { onLoad, onShow, onHide, onUnload, onBack } = mixin;
        onLoad && lifeCycleMixins.onLoad.push(onLoad);
        onShow && lifeCycleMixins.onShow.push(onShow);
        onHide && lifeCycleMixins.onHide.push(onHide);
        onUnload && lifeCycleMixins.onUnload.push(onUnload);
        onBack && lifeCycleMixins.onBack.push(onBack);
    });
    return lifeCycleMixins;
}
function applyLifeCycle(instance, func) {
    return func && func.apply(instance);
}

const vAnimation = {
    mounted(el, { value }) {
        value && el.handleAnimation(value);
    },
    updated(el, { value, oldValue }) {
        if (!value || value === oldValue) {
            return;
        }
        else {
            el.handleAnimation(value);
        }
    },
    beforeUnmount(el, { value }) {
    }
};

const DefaultDisplay = 'flex';
const vShow = {
    beforeMount(el, { value }, { transition }) {
        if (el.style.display === 'none') {
            el._vod = '';
        }
        else {
            el._vod = el.style.display || DefaultDisplay;
        }
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.setStyle({
        display: value ? el._vod : 'none',
        "flex-direction": el.style.flexDirection ? el.style.flexDirection : 'column'
    });
}

var InputEventState;
(function (InputEventState) {
    InputEventState[InputEventState["BEGIN"] = 1] = "BEGIN";
    InputEventState[InputEventState["CHANGED"] = 2] = "CHANGED";
    InputEventState[InputEventState["ENDED"] = 3] = "ENDED";
    InputEventState[InputEventState["CONFIRMED"] = 4] = "CONFIRMED";
})(InputEventState || (InputEventState = {}));
var SwitchEventState;
(function (SwitchEventState) {
    SwitchEventState[SwitchEventState["CLOSE"] = 0] = "CLOSE";
    SwitchEventState[SwitchEventState["OPEN"] = 1] = "OPEN";
})(SwitchEventState || (SwitchEventState = {}));
function addEventListener(el, event, handler) {
    el.addEventListener(event, handler);
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return shared.isArray(fn) ? value => shared.invokeArrayFns(fn, value) : fn;
};
const vModelText = {
    beforeMount(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el.value = value == null ? '' : value;
        el._assign = getModelAssigner(vnode);
        const castToNumber = !!number;
        addEventListener(el, 'input', (e) => {
            let domValue = e.text;
            if (lazy) {
                if (e.state === InputEventState.CONFIRMED || e.state === InputEventState.ENDED) {
                    let value = transformValue(trim, castToNumber, domValue);
                    el._assign(value);
                }
            }
            else {
                if (e.state === InputEventState.CHANGED) {
                    let value = transformValue(trim, castToNumber, domValue);
                    el._assign(value);
                }
            }
        });
    },
    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.focused) {
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number) && shared.toNumber(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
function transformValue(trim, castToNumber, value) {
    let domValue = value;
    if (trim) {
        domValue = domValue.trim();
    }
    if (castToNumber) {
        domValue = shared.toNumber(domValue);
    }
    return domValue;
}
const vModelSwitch = {
    beforeMount(el, { value }, vnode) {
        el.value = value == null ? '' : value;
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'switch', (e) => {
            let { state } = e;
            if (state === SwitchEventState.CLOSE) {
                el._assign(false);
            }
            else if (state === SwitchEventState.OPEN) {
                el._assign(true);
            }
        });
    },
    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.value === value) {
            return;
        }
        el.value = value;
    }
};

const extend = Object.assign;
const { render: baseRender, createApp: baseCreateApp } = runtimeCore.createRenderer(extend({ patchProp }, nodeOps));
const renderApp = baseRender;
exports.appContext = null;
exports.container = null;
const renderCustomSlot = ((vnode, container) => {
    if (!runtimeCore.isVNode(vnode)) {
        vnode = runtimeCore.createVNode(vnode);
    }
    vnode.appContext = exports.appContext;
    baseRender(vnode, container);
});
const createApp = ((...args) => {
    const app = baseCreateApp(...args);
    const { mount } = app;
    app.mount = (container) => {
        const proxy = mount(container);
        return proxy;
    };
    return app;
});
const createRootContainer = (options) => {
    return document.createPageView(options);
};
function render(App) {
    let { pageConfig } = App;
    let app = createApp(App);
    install(app);
    exports.appContext = app._context;
    exports.container = createRootContainer({
        canScroll: pageConfig && pageConfig.canScroll,
        pageStyle: pageConfig && pageConfig.pageStyle
    });
    let { plugins } = App;
    plugins && plugins.forEach((plugin) => {
        app.use(plugin);
    });
    let instance = app.mount(exports.container);
    initPageLifeCycle(exports.container, instance, App);
    exports.container.render();
    if (NODE_DEBUG_ENV) {
        require('@hummer/tenon-dev-tool').run(exports.container);
    }
}

var index = {
    render
};

exports.Base = Base;
exports.Button = Button;
exports.Image = Image;
exports.Input = Input;
exports.Page = Page;
exports.RootViewComponent = RootViewComponent;
exports.RuleKeyMap = RuleKeyMap;
exports.Switch = Switch;
exports.TextArea = TextArea;
exports.View = View;
exports.collectStyle = collectStyle;
exports.component = component;
exports.createApp = createApp;
exports.createRootContainer = createRootContainer;
exports["default"] = index;
exports.directive = directive;
exports.getClassStyle = getClassStyle;
exports.getComponent = getComponent;
exports.mixin = mixin;
exports.register = register;
exports.render = render;
exports.renderApp = renderApp;
exports.renderCustomSlot = renderCustomSlot;
exports.use = use;
exports.vAnimation = vAnimation;
exports.vModelSwitch = vModelSwitch;
exports.vModelText = vModelText;
exports.vShow = vShow;
for (var k in runtimeCore) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = runtimeCore[k];
}
//# sourceMappingURL=tenon-vue.cjs.js.map
