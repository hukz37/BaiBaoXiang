var tenon = (function (exports) {
  'use strict';

  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach(item => {
          if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
      });
      return ret;
  }

  function transformAttr(style) {
      let tempStyle = {};
      Object.keys(style).forEach(key => {
          let humpKey = transformHumpKey(key);
          tempStyle[humpKey] = style[key];
      });
      return tempStyle;
  }
  function transformHumpKey(key) {
      let humpKey = key.replace(/-(\w)/g, ($0, $1) => {
          return $1.toUpperCase();
      });
      return humpKey;
  }

  const COLOR_MAP = {
      aliceblue: '#f0f8ff',
      antiquewhite: '#faebd7',
      aqua: '#00ffff',
      aquamarine: '#7fffd4',
      azure: '#f0ffff',
      beige: '#f5f5dc',
      bisque: '#ffe4c4',
      black: '#000000',
      blanchedalmond: '#ffebcd',
      blue: '#0000ff',
      blueviolet: '#8a2be2',
      brown: '#a52a2a',
      burlywood: '#deb887',
      cadetblue: '#5f9ea0',
      chartreuse: '#7fff00',
      chocolate: '#d2691e',
      coral: '#ff7f50',
      cornflowerblue: '#6495ed',
      cornsilk: '#fff8dc',
      crimson: '#dc143c',
      cyan: '#00ffff',
      darkblue: '#00008b',
      darkcyan: '#008b8b',
      darkgoldenrod: '#b8860b',
      darkgray: '#a9a9a9',
      darkgrey: '#a9a9a9',
      darkgreen: '#006400',
      darkkhaki: '#bdb76b',
      darkmagenta: '#8b008b',
      darkolivegreen: '#556b2f',
      darkorange: '#ff8c00',
      darkorchid: '#9932cc',
      darkred: '#8b0000',
      darksalmon: '#e9967a',
      darkseagreen: '#8fbc8f',
      darkslateblue: '#483d8b',
      darkslategray: '#2f4f4f',
      darkslategrey: '#2f4f4f',
      darkturquoise: '#00ced1',
      darkviolet: '#9400d3',
      deeppink: '#ff1493',
      deepskyblue: '#00bfff',
      dimgray: '#696969',
      dimgrey: '#696969',
      dodgerblue: '#1e90ff',
      firebrick: '#b22222',
      floralwhite: '#fffaf0',
      forestgreen: '#228b22',
      fuchsia: '#ff00ff',
      gainsboro: '#dcdcdc',
      ghostwhite: '#f8f8ff',
      gold: '#ffd700',
      goldenrod: '#daa520',
      gray: '#808080',
      grey: '#808080',
      green: '#008000',
      greenyellow: '#adff2f',
      honeydew: '#f0fff0',
      hotpink: '#ff69b4',
      indianred: '#cd5c5c',
      indigo: '#4b0082',
      ivory: '#fffff0',
      khaki: '#f0e68c',
      lavender: '#e6e6fa',
      lavenderblush: '#fff0f5',
      lawngreen: '#7cfc00',
      lemonchiffon: '#fffacd',
      lightblue: '#add8e6',
      lightcoral: '#f08080',
      lightcyan: '#e0ffff',
      lightgoldenrodyellow: '#fafad2',
      lightgray: '#d3d3d3',
      lightgrey: '#d3d3d3',
      lightgreen: '#90ee90',
      lightpink: '#ffb6c1',
      lightsalmon: '#ffa07a',
      lightseagreen: '#20b2aa',
      lightskyblue: '#87cefa',
      lightslateblue: '#8470ff',
      lightslategray: '#778899',
      lightslategrey: '#778899',
      lightsteelblue: '#b0c4de',
      lightyellow: '#ffffe0',
      lime: '#00ff00',
      limegreen: '#32cd32',
      linen: '#faf0e6',
      magenta: '#ff00ff',
      maroon: '#800000',
      mediumaquamarine: '#66cdaa',
      mediumblue: '#0000cd',
      mediumorchid: '#ba55d3',
      mediumpurple: '#9370db',
      mediumseagreen: '#3cb371',
      mediumslateblue: '#7b68ee',
      mediumspringgreen: '#00fa9a',
      mediumturquoise: '#48d1cc',
      mediumvioletred: '#c71585',
      midnightblue: '#191970',
      mintcream: '#f5fffa',
      mistyrose: '#ffe4e1',
      moccasin: '#ffe4b5',
      navajowhite: '#ffdead',
      navy: '#000080',
      oldlace: '#fdf5e6',
      olive: '#808000',
      olivedrab: '#6b8e23',
      orange: '#ffa500',
      orangered: '#ff4500',
      orchid: '#da70d6',
      palegoldenrod: '#eee8aa',
      palegreen: '#98fb98',
      paleturquoise: '#afeeee',
      palevioletred: '#db7093',
      papayawhip: '#ffefd5',
      peachpuff: '#ffdab9',
      peru: '#cd853f',
      pink: '#ffc0cb',
      plum: '#dda0dd',
      powderblue: '#b0e0e6',
      purple: '#800080',
      rebeccapurple: '#663399',
      red: '#ff0000',
      rosybrown: '#bc8f8f',
      royalblue: '#4169e1',
      saddlebrown: '#8b4513',
      salmon: '#fa8072',
      sandybrown: '#f4a460',
      seagreen: '#2e8b57',
      seashell: '#fff5ee',
      sienna: '#a0522d',
      silver: '#c0c0c0',
      skyblue: '#87ceeb',
      slateblue: '#6a5acd',
      slategray: '#708090',
      slategrey: '#708090',
      snow: '#fffafa',
      springgreen: '#00ff7f',
      steelblue: '#4682b4',
      tan: '#d2b48c',
      teal: '#008080',
      thistle: '#d8bfd8',
      tomato: '#ff6347',
      transparent: '#000000',
      turquoise: '#40e0d0',
      violet: '#ee82ee',
      violetred: '#d02090',
      wheat: '#f5deb3',
      white: '#ffffff',
      whitesmoke: '#f5f5f5',
      yellow: '#ffff00',
      yellowgreen: '#9acd32'
  };
  function getColor(color) {
      return COLOR_MAP[color] || color;
  }

  function getEnvironmentInfo() {
      return {};
  }

  function traverseArr(arr, callback) {
      for (let i = 0; i < arr.length; i++) {
          let item = arr[i];
          let result = callback(item, i);
          if (!result) {
              break;
          }
      }
  }
  function makeMap(str, expectedLowerCase = false) {
      const map = Object.create(null);
      const list = str.split(',');
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectedLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  function makeMapByArr(list, expectedLowerCase = false) {
      const map = Object.create(null);
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectedLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  const camelizeRE = /-(\w)/g;
  function camelize(str) {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
  }

  const unitAttrs = [
      'font-size', 'placeholder-font-size',
      'flex-basis',
      'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height',
      'padding', 'padding-left', 'padding-right', 'padding-bottom', 'padding-top',
      'margin', 'margin-left', 'margin-right', 'margin-bottom', 'margin-top',
      'left', 'right', 'top', 'bottom',
      'border-width', 'border-left-width', 'border-right-width', 'border-top-width', 'border-bottom-width',
      'border-radius', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-left-radius', 'border-bottom-right-radius'
  ];
  const isNeedUnitTrasform = makeMapByArr(unitAttrs);
  const isRemUnit = /rem$/;
  const isVUnit = /v(h|w|min|max)$/;
  const isCpxUnit = /cpx$/;
  function transformUnit(style) {
      Object.keys(style).forEach(key => {
          if (isNeedUnitTrasform(key)) {
              let value = transformUnitValue(style[key]);
              style[key] = value;
          }
      });
      return style;
  }
  function transformUnitValue(value) {
      if (isRemUnit.test(value)) {
          return transfromRem(value);
      }
      else if (isVUnit.test(value)) {
          return transformVUnit(value);
      }
      else if (isCpxUnit.test(value)) {
          return transfromCpx(value);
      }
      return value;
  }
  function hexify(color) {
      var values = color
          .replace(/rgba?\(/, '')
          .replace(/\)/, '')
          .replace(/[\s+]/g, '')
          .split(',');
      var a = parseFloat(values[3] || "1"), r = parseInt(values[0]), g = parseInt(values[1]), b = parseInt(values[2]), a = Math.floor(a * 255);
      return "#" +
          ("0" + r.toString(16)).slice(-2) +
          ("0" + g.toString(16)).slice(-2) +
          ("0" + b.toString(16)).slice(-2) +
          ("0" + a.toString(16)).slice(-2);
  }
  function transfromRem(value) {
      let num = (Number(value.replace(/rem/, '')) * 100).toFixed(2);
      return num + 'hm';
  }
  function transfromCpx(value) {
      let num = value.replace(/cpx/, 'hm');
      return num;
  }
  function transformVUnit(value) {
      return value;
  }

  const colorAttrs = "color,background-color,border-color,border-top-color,border-left-color,border-right-color,border-bottom-color,placeholder-color,cursor-color";
  const isColorAttr = makeMap(colorAttrs);
  const rgbaReg$1 = /rgba?/;
  function transformColor(style) {
      Object.keys(style).forEach(key => {
          if (isColorAttr(key)) {
              let value = style[key];
              if (isRgba(value)) {
                  style[key] = hexify(value);
              }
              else {
                  style[key] = transformColorStyle(value);
              }
          }
      });
      return style;
  }
  function isRgba(color) {
      return rgbaReg$1.test(color);
  }
  function transformColorStyle(value) {
      if (/^#/.test(value) && value.length === 4) {
          return normalizeColor(value);
      }
      else {
          return getColor(value);
      }
  }
  function normalizeColor(value) {
      return value.replace(/(\w)/ig, function (match) {
          return `${match}${match}`;
      });
  }

  const commonAttrs = ["margin", "padding"];
  const borderAttrs = ["border-radius"];
  const attrs$2 = commonAttrs.concat(borderAttrs);
  const isDirectAttr = makeMapByArr(commonAttrs);
  const isBorderDirectAttr = makeMapByArr(borderAttrs);
  function transformBreakToken(style) {
      let tempStyle = Object.assign({}, style);
      attrs$2.forEach(attr => {
          if (!style[attr]) {
              return;
          }
          if (isDirectAttr(attr)) {
              delete tempStyle[attr];
              tempStyle = extend(breakDirectionAttr({
                  attr: attr,
                  value: style[attr]
              }), tempStyle);
          }
          else if (isBorderDirectAttr(attr)) {
              delete tempStyle[attr];
              tempStyle = extend(breakBorderRadiusAttr({
                  attr: attr,
                  value: style[attr]
              }, /\s+/), tempStyle);
          }
      });
      return tempStyle;
  }
  function breakDirectionAttr({ attr, value }, splitReg = /\s/) {
      let vals = value.split(splitReg).map(item => {
          return item.trim();
      });
      let top, right, bottom, left;
      switch (vals.length) {
          case 1:
              top = vals[0];
              right = vals[0];
              bottom = vals[0];
              left = vals[0];
              break;
          case 2:
              top = vals[0];
              right = vals[1];
              bottom = vals[0];
              left = vals[1];
              break;
          case 3:
              top = vals[0];
              right = vals[1];
              bottom = vals[2];
              left = vals[1];
              break;
          case 4:
              top = vals[0];
              right = vals[1];
              bottom = vals[2];
              left = vals[3];
              break;
          default:
              top = 0;
              bottom = 0;
              left = 0;
              right = 0;
              break;
      }
      return {
          [attr + '-top']: top,
          [attr + '-right']: right,
          [attr + '-bottom']: bottom,
          [attr + '-left']: left,
      };
  }
  function breakBorderRadiusAttr({ attr, value }, splitReg = /\s+/) {
      let vals = value.split(splitReg).map(item => {
          return item.trim();
      });
      let topLeft, topRight, bottomLeft, bottomRight;
      if (vals.length === 1) {
          return {
              'border-radius': vals[0]
          };
      }
      switch (vals.length) {
          case 1:
              topLeft = vals[0];
              topRight = vals[0];
              bottomRight = vals[0];
              bottomLeft = vals[0];
              break;
          case 2:
              topLeft = vals[0];
              topRight = vals[1];
              bottomRight = vals[0];
              bottomLeft = vals[1];
              break;
          case 3:
              topLeft = vals[0];
              topRight = vals[1];
              bottomRight = vals[2];
              bottomLeft = vals[1];
              break;
          case 4:
              topLeft = vals[0];
              topRight = vals[1];
              bottomRight = vals[2];
              bottomLeft = vals[3];
              break;
          default:
              topLeft = 0;
              topRight = 0;
              bottomRight = 0;
              bottomLeft = 0;
              break;
      }
      return {
          ['border-top-left-radius']: topLeft,
          ['border-top-right-radius']: topRight,
          ['border-bottom-right-radius']: bottomRight,
          ['border-bottom-left-radius']: bottomLeft,
      };
  }

  const rgbaReg = /rgba?\([\d\.\s,]+\)/;
  var Keyword;
  (function (Keyword) {
      Keyword["AUTO"] = "auto";
  })(Keyword || (Keyword = {}));
  var BorderStyle;
  (function (BorderStyle) {
      BorderStyle["NONE"] = "none";
      BorderStyle["SOLID"] = "solid";
      BorderStyle["DASHED"] = "dashed";
      BorderStyle["DOTTED"] = "dotted";
  })(BorderStyle || (BorderStyle = {}));
  function isNumber(num) {
      return !isNaN(num);
  }
  function isLength(length) {
      let lengthReg = /^[\d\.]+(%|rem|hm|cpx|px|vw|vh)?$/;
      return lengthReg.test(length);
  }
  function isBorderStyle(value) {
      return [BorderStyle.NONE, BorderStyle.DASHED, BorderStyle.DOTTED, BorderStyle.SOLID].findIndex((borderStyle) => {
          return value === borderStyle;
      }) !== -1;
  }
  function hasRgbaColor(value) {
      return rgbaReg.test(value);
  }
  function getRgbaColor(value) {
      if (!value) {
          return null;
      }
      let matches = value.match(rgbaReg);
      if (matches && matches.length > 0) {
          let matchStr = matches[0];
          return matchStr;
      }
      else {
          return null;
      }
  }

  const attrs$1 = ["border", "border-left", "border-right", "border-top", "border-bottom"];
  function transformBorder(style) {
      let tempStyle = Object.assign({}, style);
      attrs$1.forEach(attr => {
          if (!style[attr]) {
              return;
          }
          else {
              delete tempStyle[attr];
              tempStyle = extend(transformBorderStyle(attr, style[attr]), tempStyle);
          }
      });
      return tempStyle;
  }
  function transformBorderStyle(attr, borderValue) {
      let tempStyle = {};
      if (!hasRgbaColor(borderValue)) {
          let values = borderValue.trim().split(/\s+/);
          tempStyle = traverseBorderValue(values, attr);
      }
      else {
          let rgbaColor = getRgbaColor(borderValue);
          if (rgbaColor) {
              borderValue = borderValue.split(rgbaColor).join("");
              let values = borderValue.trim().split(/\s+/);
              tempStyle = traverseBorderValue(values, attr);
              tempStyle[attr + '-color'] = rgbaColor;
          }
          else {
              let values = borderValue.trim().split(/\s+/);
              tempStyle = traverseBorderValue(values, attr);
          }
      }
      return tempStyle;
  }
  function traverseBorderValue(values, attr) {
      let tempStyle = {};
      values.forEach((value) => {
          if (isBorderStyle(value)) {
              tempStyle[attr + "-style"] = value;
          }
          else if (isLength(value)) {
              tempStyle[attr + "-width"] = value;
          }
          else {
              tempStyle[attr + "-color"] = value;
          }
      });
      return tempStyle;
  }

  const attrs = ["box-shadow"];
  function transformShadow(style) {
      traverseArr(attrs, function (item, index) {
          if (style[item]) {
              style["shadow"] = getShadowValue(style[item]);
              delete style[item];
          }
      });
      return style;
  }
  function getShadowValue(value) {
      let values = value;
      if (!values) {
          return '';
      }
      const shadowItems = transformValue(value);
      if (shadowItems.length > 4) {
          values = [
              shadowItems[0],
              shadowItems[1],
              shadowItems[2],
              shadowItems[4]
          ].join(' ');
      }
      else {
          values = shadowItems.join(' ');
      }
      return values;
  }
  function transformValue(value) {
      const rgbReg = /rgb?/, rgbaReg = /rgba?/;
      let values = value, shadowItems = new Array();
      if (rgbReg.test(values)) {
          shadowItems = [
              ...values.slice(0, values.indexOf('rgb')).trim().split(/\s/),
              values.slice(values.indexOf('rgb'))
          ];
      }
      else {
          shadowItems = values.split(/\s/);
      }
      for (let i = 0; i < shadowItems.length; i++) {
          if (rgbaReg.test(shadowItems[i])) {
              shadowItems[i] = hexify(shadowItems[i]);
          }
          else {
              shadowItems[i] = transformUnitValue(shadowItems[i]);
          }
      }
      return shadowItems;
  }

  const borderRadius$1 = "border-radius,border-top-left-radius,border-top-right-radius,border-bottom-left-radius,border-bottom-right-radius";
  const isBorderRadius$1 = makeMap(borderRadius$1);
  function transformAdapter(style) {
      let tempStyle = Object.assign({}, style);
      tempStyle = hackForBorderRadius$1(tempStyle);
      tempStyle = hackForDefaultFlex(tempStyle);
      tempStyle = hackForWhiteSpace(tempStyle);
      return tempStyle;
  }
  function hackForWhiteSpace(style) {
      if (style['white-space'] === 'nowrap') {
          style['textLineClamp'] = "1";
      }
      return style;
  }
  function hackForDefaultFlex(style) {
      if (style['display'] === 'flex' && !style['flex-direction']) {
          style['flex-direction'] = 'row';
      }
      return style;
  }
  function hackForBorderRadius$1(style) {
      if (hasSpecialAttr$1(style, isBorderRadius$1)) {
          transformBorderRadius(style);
      }
      return style;
  }
  function hasSpecialAttr$1(obj, func) {
      return Object.keys(obj).some(key => {
          return func(key);
      });
  }
  function transformBorderRadius(style) {
      if (!style.width) {
          return;
      }
      let [, width, unit] = style.width.split(/([\d\.]+)/);
      if (unit === '%') {
          return;
      }
      Object.keys(style).forEach(key => {
          if (isBorderRadius$1(key)) {
              style[key] = getBorderRadius(style[key], { width, unit });
          }
      });
  }
  function getBorderRadius(value, { width, unit }) {
      let [, bPercent, bUnit] = value.split(/([\d\.]+)/);
      if (bUnit === '%') {
          return (width * parseFloat(bPercent) / 100).toFixed(2) + unit;
      }
      return value;
  }

  const CLIP_LIST = [
      'border-box',
      'padding-box',
      'content-box',
      'text'
  ];
  const REPEAT_LIST = [
      'repeat-x',
      'repeat-y',
      'repeat',
      'space',
      'round',
      'no-repeat'
  ];
  const SIZE_LIST = [
      'contain',
      'cover'
  ];

  const isUrl = /url\((?:"|')/;
  const isImageBase64Reg = /url\(data:/;
  const isLinearGradient = /linear\-gradient/;
  const imageUrlReg = /url\((?:"|')?([\w\W]+)(?:"|')\)/;
  const imageBase64Reg = /url\(([\w\W]+)\)/;
  const linearReg = /linear\-gradient\(([\w\W]+)\)/;
  function transformBackground(style) {
      let tempStyle = Object.assign({}, style);
      if (tempStyle['background-image']) {
          let value = tempStyle['background-image'];
          if (isLinearGradient.test(value.trim())) {
              delete tempStyle['background-image'];
              let matches = value.match(linearReg);
              let linearValue = matches && matches[1] || '';
              tempStyle['background-color'] = 'linear-gradient(' + transformLinear(linearValue) + ')';
          }
          else {
              tempStyle['background-image'] = transformBackgroundImage(value);
          }
      }
      if (tempStyle['background']) {
          const value = tempStyle['background'];
          delete tempStyle['background'];
          tempStyle = Object.assign(Object.assign({}, splitBackground(value)), tempStyle);
      }
      return tempStyle;
  }
  function splitBackground(value) {
      let newBackgroundMap = {};
      const colorKeys = Object.keys(COLOR_MAP).join('|');
      const color = '(#\\w{3,8})|(rgba?\\(.+\\))';
      const isColor = new RegExp(`(${color}|${colorKeys})`);
      if (isColor.test(value)) {
          const match = isColor.exec(value);
          if (match) {
              newBackgroundMap['background-color'] = match[0];
          }
      }
      if (isUrl.test(value)) {
          const urlMatch = /url\(.+\)/;
          const match = urlMatch.exec(value);
          let backgorundImage = match && match[0];
          if (backgorundImage) {
              newBackgroundMap['background-image'] = transformBackgroundImage(backgorundImage);
          }
      }
      const clipMatch = matchKeyList(CLIP_LIST, value);
      if (clipMatch) {
          newBackgroundMap['backgrond-clip'] = clipMatch;
      }
      const repeatMatch = matchKeyList(REPEAT_LIST, value);
      if (repeatMatch) {
          newBackgroundMap['background-repeat'] = repeatMatch;
      }
      const sizeMatch = matchKeyList(SIZE_LIST, value);
      if (sizeMatch) {
          newBackgroundMap['background-size'] = sizeMatch;
      }
      return newBackgroundMap;
  }
  function matchKeyList(list, value) {
      const matchList = list.join('|');
      const isList = new RegExp(matchList);
      if (isList.test(value)) {
          const match = isList.exec(value);
          if (match) {
              return match[0];
          }
      }
      return '';
  }
  function transformBackgroundImage(value) {
      let backgroundImage = value.trim();
      if (isUrl.test(backgroundImage)) {
          let matches = backgroundImage.match(imageUrlReg);
          return (matches && matches[1]) || '';
      }
      else if (isImageBase64Reg.test(backgroundImage)) {
          let matches = backgroundImage.match(imageBase64Reg);
          return (matches && matches[1]) || '';
      }
      return '';
  }
  function transformLinear(value) {
      let backgroundLinear = value.replace(/\s+/g, '');
      let isRgba = /rgba?/;
      let rgbaReg = /rgba\(\d+,\d+,\d+,[\d\.]+\)/g;
      if (isRgba.test(backgroundLinear)) {
          let matcheList = backgroundLinear.match(rgbaReg);
          for (let item in matcheList) {
              backgroundLinear = backgroundLinear.replace(matcheList[parseInt(item)], hexify(matcheList[parseInt(item)]));
          }
      }
      backgroundLinear = backgroundLinear.split(',').map(res => getColor(res)).join(' ');
      return backgroundLinear;
  }

  function transformFlex(style) {
      let tempStyle = Object.assign({}, style);
      if (tempStyle['flex']) {
          let value = tempStyle['flex'];
          delete tempStyle['flex'];
          tempStyle = Object.assign(Object.assign(Object.assign({}, defaultFlexStyle), transformFlexStyle(value + "")), tempStyle);
      }
      return tempStyle;
  }
  const defaultFlexStyle = {
      "flex-grow": 0,
      "flex-shrink": 0,
      "flex-basis": 'auto'
  };
  function transformFlexStyle(flexStyleValue) {
      let tempStyle = {};
      let values = flexStyleValue.trim().split(/\s+/);
      switch (values.length) {
          case 1:
              tempStyle = handleFlexStyleBy1(values);
              break;
          case 2:
              tempStyle = handleFlexStyleBy2(values);
              break;
          case 3:
              tempStyle = handleFlexStyleBy3(values);
              break;
      }
      return tempStyle;
  }
  function handleFlexStyleBy1(values) {
      let value = values[0];
      let tempStyle = {};
      if (isNaN(parseInt(value))) {
          tempStyle["flex-basis"] = value;
      }
      else {
          if (value === "0") {
              tempStyle["flex-basis"] = 0;
          }
          else {
              tempStyle["flex-grow"] = Number(value);
              tempStyle["flex-shrink"] = Number(value);
          }
      }
      return tempStyle;
  }
  function handleFlexStyleBy2(values) {
      let tempStyle = {};
      let [firstValue, secondValue] = values;
      if (firstValue) {
          tempStyle["flex-grow"] = firstValue;
      }
      if (secondValue) {
          if (isNumber(secondValue)) {
              tempStyle["flex-shrink"] = Number(secondValue);
          }
          else {
              tempStyle["flex-basis"] = secondValue;
          }
      }
      return tempStyle;
  }
  function handleFlexStyleBy3(values) {
      let [firstValue, secondValue, thirdValue] = values;
      return {
          "flex-grow": firstValue,
          "flex-shrink": secondValue,
          "flex-basis": thirdValue
      };
  }

  function transformTransform(style) {
      let tempStyle = Object.assign({}, style);
      if (tempStyle['transform']) {
          let value = tempStyle['transform'];
          tempStyle = Object.assign(Object.assign({}, tempStyle), splitToArray(transTranslateUnit(replaceDeg(value))));
      }
      return tempStyle;
  }
  function splitToArray(params) {
      return {
          transform: params.trim().split(/\s+/g).join(',')
      };
  }
  function replaceDeg(str) {
      return str.replace(/deg/g, '');
  }
  function transTranslateUnit(str) {
      let arr = (str.replace(/\s/g, '').match(/[a-zA-Z0-9]+\(.+?\)/g)) || [];
      arr.map((item, index) => {
          if (item.indexOf('translate') > -1 || item.indexOf('position') > -1) {
              let temp = item.match(/[^(][a-zA-Z0-9,]+(?=\))/g);
              let key = item.split('(')[0];
              let value = temp ? temp[0] : '0';
              value = value.split(',').map(v => transformUnitValue(v)).join(',');
              arr[index] = `${key}(${value})`;
          }
      });
      return arr.join(' ');
  }

  const transitionFullProperty = ['transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'];
  function transformTransition(style) {
      let tempStyle = Object.assign({}, style);
      transitionFullProperty.forEach(property => {
          if (tempStyle[property]) {
              let value = tempStyle[property];
              tempStyle = Object.assign(Object.assign({}, getHummerProp(property, value)), tempStyle);
              delete tempStyle[property];
          }
      });
      if (tempStyle['transition']) {
          let value = tempStyle['transition'];
          tempStyle = Object.assign(Object.assign({}, splitToFullProps(value)), tempStyle);
          delete tempStyle['transition'];
      }
      return tempStyle;
  }
  function getHummerProp(property, value) {
      let obj = {};
      obj[property] = isTime(value) ? value.replace('s', '') : value;
      return obj;
  }
  function splitToFullProps(params) {
      let transitionPropertyArray = [];
      let transitionDurationArray = [];
      let transitionTimingFunctionArray = [];
      let transitionDelayArray = [];
      let transitionArray = params.split(',');
      transitionArray.forEach(transition => {
          let transitonValues = transition.trim().split(/\s+/g);
          transitonValues = getFullValues(transitonValues);
          transitionPropertyArray.push(transitonValues[0]);
          transitionDurationArray.push(transitonValues[1].replace('s', ''));
          transitionTimingFunctionArray.push(transitonValues[2]);
          transitionDelayArray.push(transitonValues[3].replace('s', ''));
      });
      return {
          'transition-property': transitionPropertyArray.join(','),
          'transition-duration': transitionDurationArray.join(','),
          'transition-timing-function': transitionTimingFunctionArray[0],
          'transition-delay': transitionDelayArray[0]
      };
  }
  function getFullValues(transitonValues) {
      let tempArray = [];
      tempArray = [...transitonValues];
      if (transitonValues.length === 2) {
          tempArray = [...transitonValues, 'ease', '0s'];
      }
      else if (transitonValues.length === 3) {
          if (isTime(transitonValues[2])) {
              tempArray = [transitonValues[0], transitonValues[1], 'ease', transitonValues[2]];
          }
          else {
              tempArray = [...transitonValues, '0s'];
          }
      }
      return tempArray;
  }
  function isTime(str) {
      return /^\d*[s]$/.test(str);
  }

  const NODE_VIEW = Symbol('NODE_VIEW');
  const NODE_TEXT = Symbol('NODE_TEXT');
  const NODE_IMAGE = Symbol('NODE_IMAGE');
  const NODE_BUTTON = Symbol('NODE_BUTTON');
  const NODE_TEXTAREA = Symbol('NODE_TEXTAREA');
  const NODE_INPUT = Symbol('NODE_INPUT');
  const NODE_SWITCH = Symbol('NODE_SWITCH');
  const NODE_SCROLLER = Symbol('NODE_SCROLLER');
  const NODE_VIEW_PAGER = Symbol('NODE_VIEW_PAGER');
  const NODE_LIST = Symbol('NODE_LIST');
  const NODE_DIALOG = Symbol('NODE_DIALOG');
  const NODE_ANIMATION_VIEW = Symbol('NODE_ANIMATION_VIEW');
  const NODE_COMMENT = Symbol('NODE_COMMENT');
  const NODE_ANCHOR = Symbol('NODE_ANCHOR');
  const NODE_REFRESH = Symbol('NODE_REFRESH');
  const NODE_LOADMORE = Symbol('NODE_LOADMORE');
  const ELEMNT_TAG_MAP = {
      [NODE_VIEW]: 'view',
      [NODE_TEXT]: 'text',
      [NODE_IMAGE]: 'image',
      [NODE_BUTTON]: 'button',
      [NODE_TEXTAREA]: 'textarea',
      [NODE_INPUT]: 'input',
      [NODE_SWITCH]: 'switch',
      [NODE_SCROLLER]: 'scroller',
      [NODE_VIEW_PAGER]: 'viewpager',
      [NODE_LIST]: 'list',
      [NODE_DIALOG]: 'dialog',
      [NODE_ANIMATION_VIEW]: 'animation',
      [NODE_ANCHOR]: 'anchor',
      [NODE_REFRESH]: 'refresh',
      [NODE_LOADMORE]: 'loadmore'
  };

  const borderRadius = 'borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomLeftRadius,borderBottomRightRadius';
  const isBorderRadius = makeMap(borderRadius);
  function dynamicTransformAdapter(style, view) {
      let tempStyle = {};
      tempStyle = hackForBorderRadius(view, style);
      return tempStyle;
  }
  function hackForBorderRadius(view, style) {
      if (view && view.__NAME === NODE_IMAGE && hasSpecialAttr(style, isBorderRadius)) {
          style['overflow'] = 'hidden';
      }
      return style;
  }
  function hasSpecialAttr(obj, func) {
      return Object.keys(obj).some(key => {
          return func(key);
      });
  }

  class StyleTransformer {
      constructor() {
          this.middlewares = [];
          this.registerMiddleware();
      }
      registerMiddleware() {
          this
              .use(transformAdapter)
              .use(transformBreakToken)
              .use(transformBackground)
              .use(transformTransform)
              .use(transformTransition)
              .use(transformFlex)
              .use(transformBorder)
              .use(transformShadow)
              .use(transformColor)
              .use(transformUnit)
              .use(transformAttr);
      }
      use(middleware) {
          if (typeof middleware !== 'function') {
              throw "middleware must be a function";
          }
          this.middlewares.push(middleware);
          return this;
      }
      transformStyle(style = {}, view) {
          let tempStyle = style;
          this.middlewares.forEach(middleware => {
              let result = middleware(tempStyle, view);
              tempStyle = result ? result : tempStyle;
          });
          return tempStyle;
      }
  }
  class StyleDynamicTransformer {
      constructor() {
          this.middlewares = [];
          this.registerMiddleware();
      }
      registerMiddleware() {
          this
              .use(dynamicTransformAdapter);
      }
      use(middleware) {
          if (typeof middleware !== 'function') {
              throw "middleware must be a function";
          }
          this.middlewares.push(middleware);
          return this;
      }
      transformStyle(style = {}, view) {
          let tempStyle = style;
          this.middlewares.forEach(middleware => {
              let result = middleware(tempStyle, view);
              tempStyle = result ? result : tempStyle;
          });
          return tempStyle;
      }
  }
  const styleTransformer = new StyleTransformer();
  const styleDynamicTransformer = new StyleDynamicTransformer();

  const isNativeTagReg = /^ex-/;
  const NativeTags = "view,text,image,input,textarea,button,scroller,switch,refresh,loadmore,list,viewpager";
  const isNativeTags = makeMap(NativeTags);
  const isCustomNativeTag = (tag) => {
      return isNativeTagReg.test(tag);
  };

  const extend = Object.assign;

  exports.ELEMNT_TAG_MAP = ELEMNT_TAG_MAP;
  exports.NODE_ANCHOR = NODE_ANCHOR;
  exports.NODE_ANIMATION_VIEW = NODE_ANIMATION_VIEW;
  exports.NODE_BUTTON = NODE_BUTTON;
  exports.NODE_COMMENT = NODE_COMMENT;
  exports.NODE_DIALOG = NODE_DIALOG;
  exports.NODE_IMAGE = NODE_IMAGE;
  exports.NODE_INPUT = NODE_INPUT;
  exports.NODE_LIST = NODE_LIST;
  exports.NODE_LOADMORE = NODE_LOADMORE;
  exports.NODE_REFRESH = NODE_REFRESH;
  exports.NODE_SCROLLER = NODE_SCROLLER;
  exports.NODE_SWITCH = NODE_SWITCH;
  exports.NODE_TEXT = NODE_TEXT;
  exports.NODE_TEXTAREA = NODE_TEXTAREA;
  exports.NODE_VIEW = NODE_VIEW;
  exports.NODE_VIEW_PAGER = NODE_VIEW_PAGER;
  exports.NativeTags = NativeTags;
  exports.camelize = camelize;
  exports.extend = extend;
  exports.getColor = getColor;
  exports.getEnvironmentInfo = getEnvironmentInfo;
  exports.isCustomNativeTag = isCustomNativeTag;
  exports.isNativeTags = isNativeTags;
  exports.makeMap = makeMap;
  exports.makeMapByArr = makeMapByArr;
  exports.parseStringStyle = parseStringStyle;
  exports.styleDynamicTransformer = styleDynamicTransformer;
  exports.styleTransformer = styleTransformer;
  exports.transformUnitValue = transformUnitValue;
  exports.traverseArr = traverseArr;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
//# sourceMappingURL=tenon-utils.js.map
